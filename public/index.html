<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>O,No Online</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800;900&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <!-- Apply saved theme BEFORE CSS renders to prevent flash and ensure vars are correct -->
    <script>
        (function() {
            var t = localStorage.getItem('ono-theme') || 'light';
            document.documentElement.setAttribute('data-theme', t);
        })();
    </script>
    <style>
        /* =============================================
           CSS VARIABLE THEME SYSTEM (Light / Dark)
        ============================================= */
        :root {
            --bg-grad-a: #667eea;
            --bg-grad-b: #764ba2;
            /* Menus / surfaces */
            --surface: rgba(255,255,255,0.97);
            --surface-glass: rgba(255,255,255,0.12);
            --surface-glass-strong: rgba(255,255,255,0.22);
            --surface-inset: rgba(255,255,255,0.15);
            --surface-slot: rgba(255,255,255,0.12);
            --surface-slot-you: rgba(102,126,234,0.25);
            --surface-slot-empty: rgba(255,255,255,0.05);
            --surface-rule-item: rgba(255,255,255,0.08);
            /* Text */
            --text-primary: #333;
            --text-secondary: #555;
            --text-muted: #666;
            --text-on-glass: #fff;
            --text-mono: rgba(0,0,0,0.7);
            /* Cards */
            --card-border: rgba(255,255,255,0.65);
            --card-inner-bg: rgba(255,255,255,0.92);
            --card-shadow: 0 6px 20px rgba(0,0,0,0.32);
            --card-hover-shadow: 0 14px 36px rgba(0,0,0,0.45);
            --draw-pile-bg: linear-gradient(145deg, #1a1a2e 0%, #16213e 45%, #0f3460 100%);
            --draw-pile-border: rgba(255,255,255,0.22);
            --draw-pile-glow: rgba(100,130,255,0.3);
            /* UI chrome */
            --menu-shadow: 0 20px 60px rgba(0,0,0,0.4);
            --menu-h1: #667eea;
            --game-container-bg: rgba(255,255,255,0.08);
            --opp-box-bg: rgba(255,255,255,0.14);
            --info-chip-bg: rgba(255,255,255,0.22);
            --input-border: #667eea;
            --input-bg: #fff;
            --input-text: #333;
            --lobby-card-bg: #fff;
            --popup-bg: #fff;
            --popup-text: #333;
            --popup-sub: #555;
            --slider-bg: #ccc;
            --slider-knob: #fff;
            --lobby-header-bg: rgba(255,255,255,0.15);
            --lobby-id-color: rgba(0,0,0,0.7);
            --rules-bg: rgba(255,255,255,0.12);
        }

        html[data-theme="dark"] {
            --bg-grad-a: #0d0d1a;
            --bg-grad-b: #1a0a2e;
            /* Menus / surfaces */
            --surface: rgba(18,18,32,0.98);
            --surface-glass: rgba(255,255,255,0.055);
            --surface-glass-strong: rgba(255,255,255,0.1);
            --surface-inset: rgba(255,255,255,0.06);
            --surface-slot: rgba(255,255,255,0.07);
            --surface-slot-you: rgba(140,100,255,0.2);
            --surface-slot-empty: rgba(255,255,255,0.03);
            --surface-rule-item: rgba(255,255,255,0.05);
            /* Text */
            --text-primary: #e0e0ff;
            --text-secondary: #a0a0cc;
            --text-muted: #8888aa;
            --text-on-glass: #e0e0ff;
            --text-mono: rgba(200,200,255,0.7);
            /* Cards */
            --card-border: rgba(255,255,255,0.16);
            --card-inner-bg: rgba(10,10,22,0.78);
            --card-shadow: 0 6px 24px rgba(0,0,0,0.7), 0 0 0 1px rgba(255,255,255,0.05);
            --card-hover-shadow: 0 14px 40px rgba(0,0,0,0.85), 0 0 22px rgba(140,100,255,0.3);
            --draw-pile-bg: linear-gradient(145deg, #07070f 0%, #0b0b1c 45%, #0a0820 100%);
            --draw-pile-border: rgba(140,100,255,0.4);
            --draw-pile-glow: rgba(140,100,255,0.35);
            /* UI chrome */
            --menu-shadow: 0 20px 80px rgba(0,0,0,0.85), 0 0 0 1px rgba(255,255,255,0.04);
            --menu-h1: #a78bfa;
            --game-container-bg: rgba(255,255,255,0.03);
            --opp-box-bg: rgba(255,255,255,0.055);
            --info-chip-bg: rgba(255,255,255,0.07);
            --input-border: #7c3aed;
            --input-bg: rgba(20,20,40,0.9);
            --input-text: #e0e0ff;
            --lobby-card-bg: rgba(25,25,48,0.97);
            --popup-bg: rgba(18,18,34,0.98);
            --popup-text: #e0e0ff;
            --popup-sub: #a0a0cc;
            --slider-bg: #3a3a60;
            --slider-knob: #e0e0ff;
            --lobby-header-bg: rgba(255,255,255,0.06);
            --lobby-id-color: rgba(200,200,255,0.6);
            --rules-bg: rgba(255,255,255,0.05);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

    body {
        font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
        background-color: var(--bg-grad-a);
        background-image: linear-gradient(135deg, var(--bg-grad-a) 0%, var(--bg-grad-b) 100%);
        background-attachment: fixed;
        transition: background-color 0.5s ease;
        min-height: 100vh;
        min-height: -webkit-fill-available;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
        overflow-x: hidden;
        touch-action: pan-y;
        margin: 0;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    /* Background Animation Classes */
    body.bg-static {
        background-image: linear-gradient(135deg, var(--bg-grad-a) 0%, var(--bg-grad-b) 100%);
        background-attachment: fixed;
    }

    body.bg-color-cycle {
        background-image: linear-gradient(135deg, var(--bg-grad-a) 0%, var(--bg-grad-b) 100%);
        background-attachment: fixed;
        animation: colorCycle 15s ease-in-out infinite;
    }

    body.bg-pulsing {
        background-image: linear-gradient(-45deg, var(--bg-grad-a), var(--bg-grad-b), var(--bg-grad-a), var(--bg-grad-b));
        background-size: 400% 400%;
        background-attachment: fixed;
        animation: pulsing 10s ease infinite;
    }

    /* Keyframe Animations */
    @keyframes colorCycle {
        0% {
            background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        25% {
            background-image: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        50% {
            background-image: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        75% {
            background-image: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        100% {
            background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
    }

    @keyframes pulsing {
        0% {
            background-position: 0% 50%;
        }
        50% {
            background-position: 100% 50%;
        }
        100% {
            background-position: 0% 50%;
        }
    }

    .screen {
        display: none;
        width: 100%;
        max-width: 1000px;
    }

    .screen.active {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        width: 100%;
    }

    .menu-container {
        background: var(--surface);
        border-radius: 30px;
        padding: 40px;
        box-shadow: var(--menu-shadow);
        text-align: center;
        max-width: 600px;
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        color: var(--text-primary);
        transition: background 0.4s ease, box-shadow 0.4s ease;
    }

    h1 {
        font-family: 'Orbitron', sans-serif;
        font-size: 3.5em;
        color: var(--menu-h1);
        margin-bottom: 20px;
        text-shadow: 3px 3px 12px rgba(0, 0, 0, 0.2);
        letter-spacing: 2px;
    }

    h2 {
        font-size: 2em;
        color: var(--menu-h1);
        margin-bottom: 15px;
    }

    .menu-button {
        display: block;
        width: 100%;
        background-color: #667eea;
        background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 20px;
        font-size: 1.3em;
        font-weight: 600;
        border-radius: 15px;
        cursor: pointer;
        margin-bottom: 15px;
        transition: all 0.3s;
        box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        touch-action: manipulation;
        -webkit-appearance: none;
    }

    .menu-button:active {
        transform: translateY(2px);
        box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);
    }

    .menu-button.online {
        background-color: #2ecc71;
        background-image: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
    }

    .menu-button.offline {
        background-color: #3498db;
        background-image: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    }

    .menu-button.create {
        background-color: #f39c12;
        background-image: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
    }

    input[type="text"], select {
        width: 100%;
        padding: 15px;
        font-size: 1.2em;
        border: 2px solid var(--input-border);
        border-radius: 10px;
        margin-bottom: 20px;
        background: var(--input-bg);
        color: var(--input-text);
        transition: background 0.3s, color 0.3s, border-color 0.3s;
    }

    .lobby-list {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin: 20px 0;
        max-height: 400px;
        overflow-y: auto;
    }

    .lobby-card {
        background: var(--lobby-card-bg);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        text-align: left;
        cursor: pointer;
        transition: transform 0.2s, border-color 0.2s;
        border: 3px solid transparent;
        color: var(--text-primary);
    }

    .lobby-card:hover {
        transform: translateY(-3px);
        border-color: var(--input-border);
    }

    .lobby-card.is-private {
        border-color: rgba(231, 76, 60, 0.35);
    }

    .lobby-card.is-private:hover {
        border-color: rgba(231, 76, 60, 0.7);
    }

    .lobby-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .lobby-name {
        font-size: 1.3em;
        font-weight: bold;
        color: #667eea;
    }

    .lobby-players {
        background: #2ecc71;
        color: white;
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: bold;
    }

    .lobby-info {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
    }

    .lobby-tag {
        background: #ecf0f1;
        background-color: #ecf0f1;
        color: #34495e;
        padding: 5px 10px;
        border-radius: 8px;
        font-size: 0.85em;
    }

    .lobby-tag.active {
        background: #3498db;
        background-color: #3498db;
        color: white;
    }

    .setting-item {
        margin-bottom: 20px;
        text-align: left;
    }

    .setting-item label {
        display: block;
        font-size: 1.1em;
        color: var(--text-primary);
        margin-bottom: 8px;
        font-weight: 600;
    }

    .toggle-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
    }

    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider-toggle {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--slider-bg);
        transition: .4s;
        border-radius: 34px;
    }

    .slider-toggle:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: var(--slider-knob);
        transition: .4s;
        border-radius: 50%;
    }

    input:checked + .slider-toggle {
        background-color: #2ecc71;
    }

    input:checked + .slider-toggle:before {
        transform: translateX(26px);
    }

    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: #7f8c8d;
    }

    .empty-state-icon {
        font-size: 4em;
        margin-bottom: 15px;
    }

    /* Game styles */
    .game-info {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        align-items: center;
        color: var(--text-on-glass);
        font-size: 0.95em;
        gap: 10px;
        width: 100%;
    }

    .game-info div {
        background: var(--info-chip-bg);
        padding: 6px 14px;
        border-radius: 10px;
        border: 1px solid var(--surface-glass);
    }

    .opponent-area {
        display: none; /* replaced by oval seats */
    }

    .opponent-cards {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 10px;
    }

    .card-back-small {
        width: 50px;
        height: 75px;
        background: var(--draw-pile-bg);
        border-radius: 8px;
        border: 2px solid var(--draw-pile-border);
        box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    }

    /* =============================================
       OVAL TABLE LAYOUT
    ============================================= */
    .game-table-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 900px;
        margin: 0 auto;
        padding: 10px;
        gap: 10px;
    }

    .table-arena {
        position: relative;
        width: 100%;
        max-width: 820px;
        aspect-ratio: 4/3;
        background: radial-gradient(ellipse 70% 60% at 50% 50%,
            rgba(255,255,255,0.07) 0%,
            rgba(255,255,255,0.02) 60%,
            transparent 100%);
        border: 2px solid rgba(255,255,255,0.12);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 60px rgba(0,0,0,0.3), inset 0 0 40px rgba(0,0,0,0.15);
    }

    .direction-svg {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.85;
    }

    .dir-arc {
        transition: opacity 0.4s;
    }

    .play-area {
        position: relative;
        z-index: 2;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
    }

    /* Player seat positioned absolutely around the oval */
    .player-seat {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        z-index: 3;
        transform: translate(-50%, -50%);
        transition: all 0.3s ease;
    }

    .seat-box {
        background: var(--opp-box-bg);
        backdrop-filter: blur(8px);
        border: 2px solid rgba(255,255,255,0.15);
        border-radius: 12px;
        padding: 8px 12px;
        text-align: center;
        color: var(--text-on-glass);
        min-width: 90px;
        transition: border-color 0.25s, box-shadow 0.25s, transform 0.25s;
        font-size: 0.82em;
        cursor: default;
        white-space: nowrap;
    }

    .seat-box.is-you {
        background: rgba(102,126,234,0.25);
        border-color: rgba(102,126,234,0.6);
        box-shadow: 0 0 18px rgba(102,126,234,0.35);
    }

    .seat-box.is-current {
        border-color: #2ecc71;
        box-shadow: 0 0 18px rgba(46,204,113,0.55);
        animation: seatPulse 1.2s ease-in-out infinite;
    }

    .seat-box.is-you.is-current {
        border-color: #f1c40f;
        box-shadow: 0 0 20px rgba(241,196,15,0.6);
        background: rgba(241,196,15,0.18);
    }

    @keyframes seatPulse {
        0%, 100% { box-shadow: 0 0 18px rgba(46,204,113,0.55); }
        50%       { box-shadow: 0 0 30px rgba(46,204,113,0.85); }
    }

    .seat-name {
        font-weight: 700;
        font-size: 1em;
        max-width: 100px;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .seat-cards {
        font-size: 1.1em;
        color: #f1c40f;
        margin-top: 2px;
    }

    .seat-turn-badge {
        font-size: 0.78em;
        color: #2ecc71;
        font-weight: 700;
        margin-top: 2px;
    }

    .seat-you-badge {
        font-size: 0.72em;
        background: rgba(102,126,234,0.35);
        color: #a78bfa;
        border-radius: 6px;
        padding: 1px 6px;
        font-weight: 700;
        margin-top: 2px;
    }

    .catch-button {
        margin-top: 5px;
        padding: 3px 10px;
        background: #e74c3c;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        font-size: 0.82em;
        animation: catchPulse 1s ease-in-out infinite;
    }
    @keyframes catchPulse {
        0%, 100% { box-shadow: 0 0 0 0 rgba(231,76,60,0.7); }
        50%       { box-shadow: 0 0 0 6px rgba(231,76,60,0); }
    }

    /* O,No diagonal ribbon on seat box */
    .seat-box {
        position: relative;
        overflow: hidden;
    }
    .ono-ribbon {
        position: absolute;
        top: 10px;
        right: -22px;
        width: 80px;
        background: linear-gradient(135deg, #f1c40f, #e67e22);
        color: #1a1a1a;
        font-size: 0.6em;
        font-weight: 900;
        text-align: center;
        padding: 2px 0;
        transform: rotate(45deg);
        transform-origin: center;
        pointer-events: none;
        z-index: 10;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.35);
    }

    /* Direction indicator text label in center */
    .direction-label {
        position: absolute;
        bottom: 8%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.78em;
        color: rgba(255,255,255,0.5);
        letter-spacing: 1px;
        pointer-events: none;
        z-index: 2;
    }

    /* =============================================
       PREMIUM CARD DESIGN (from animation-test)
    ============================================= */
    .card {
        width: 100px;
        height: 150px;
        border-radius: 14px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition:
            transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1),
            box-shadow 0.25s ease,
            filter 0.25s ease;
        box-shadow: var(--card-shadow);
        border: 3px solid var(--card-border);
        touch-action: manipulation;
        position: relative;
        overflow: hidden;
    }

    /* Glossy sheen overlay on every card */
    .card::before {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 11px;
        background: linear-gradient(
            145deg,
            rgba(255,255,255,0.28) 0%,
            rgba(255,255,255,0.06) 40%,
            transparent 60%
        );
        pointer-events: none;
    }

    .card:active {
        transform: scale(0.95);
        transition: transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @media (hover: hover) {
        .card:hover {
            transform: translateY(-7px) scale(1.04);
            box-shadow: var(--card-hover-shadow);
            filter: brightness(1.08);
        }
    }

    /* Card inner oval — value display */
    .card-inner {
        width: 78%;
        height: 78%;
        background: var(--card-inner-bg);
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2em;
        font-weight: 900;
        font-family: 'Orbitron', sans-serif;
        letter-spacing: -1px;
        box-shadow: 0 2px 12px rgba(0,0,0,0.25);
        border: 2px solid rgba(255,255,255,0.2);
        transition: background 0.4s ease;
    }

    /* Color variants — rich gradients */
    .card.red {
        background: linear-gradient(145deg, #e74c3c 0%, #c0392b 60%, #96281b 100%);
    }
    .card.red .card-inner { color: #e74c3c; }

    .card.blue {
        background: linear-gradient(145deg, #3498db 0%, #2471a3 60%, #1a5276 100%);
    }
    .card.blue .card-inner { color: #2471a3; }

    .card.green {
        background: linear-gradient(145deg, #2ecc71 0%, #27ae60 60%, #1e8449 100%);
    }
    .card.green .card-inner { color: #1e8449; }

    .card.yellow {
        background: linear-gradient(145deg, #f1c40f 0%, #d4ac0d 60%, #b7950b 100%);
    }
    .card.yellow .card-inner { color: #9a7d0a; }

    .card.wild {
        background: conic-gradient(
            from 0deg,
            #e74c3c 0deg 90deg,
            #3498db 90deg 180deg,
            #2ecc71 180deg 270deg,
            #f1c40f 270deg 360deg
        );
    }
    .card.wild .card-inner { color: #1a1a2e; background: rgba(255,255,255,0.9); }

    /* Dark mode — card inner becomes dark with bright text */
    html[data-theme="dark"] .card.red    .card-inner { color: #ff6b6b; }
    html[data-theme="dark"] .card.blue   .card-inner { color: #5dade2; }
    html[data-theme="dark"] .card.green  .card-inner { color: #58d68d; }
    html[data-theme="dark"] .card.yellow .card-inner { color: #f9ca24; }
    html[data-theme="dark"] .card.wild   .card-inner { color: #fff; background: rgba(15,10,30,0.85); }

    /* +12 rare wild card — black with gold */
    .card.plus12 {
        background: linear-gradient(145deg, #0a0a0a 0%, #1a1a1a 40%, #2a1a00 100%);
        box-shadow: 0 6px 20px rgba(0,0,0,0.7),
                    0 0 20px rgba(255,180,0,0.4),
                    0 0 40px rgba(255,100,0,0.2),
                    inset 0 1px 0 rgba(255,180,0,0.2);
        border: 2px solid rgba(255,180,0,0.5) !important;
    }
    .card.plus12 .card-inner {
        color: #0a0a0a;
        background: linear-gradient(135deg, #ffd700, #ff8c00);
        font-size: 1.1em;
        font-weight: 900;
        box-shadow: 0 0 12px rgba(255,180,0,0.6);
    }
    html[data-theme="dark"] .card.plus12 .card-inner {
        color: #0a0a0a;
        background: linear-gradient(135deg, #ffd700, #ff6a00);
    }

    /* Pulse glow on +12 card in hand */
    .player-hand .card.plus12 {
        animation: plus12Glow 2s ease-in-out infinite;
    }
    @keyframes plus12Glow {
        0%, 100% { box-shadow: 0 6px 20px rgba(0,0,0,0.7), 0 0 18px rgba(255,160,0,0.5); }
        50%       { box-shadow: 0 8px 28px rgba(0,0,0,0.8), 0 0 36px rgba(255,100,0,0.8), 0 0 60px rgba(255,60,0,0.3); }
    }

    /* Card-back: the draw pile card */
    .card.card-back {
        background: var(--draw-pile-bg);
        border-color: var(--draw-pile-border);
        box-shadow: var(--card-shadow), 0 0 18px var(--draw-pile-glow);
    }

    .card.card-back::after {
        content: '';
        position: absolute;
        inset: 8px;
        border-radius: 8px;
        border: 1.5px solid rgba(255,255,255,0.12);
        pointer-events: none;
    }

    .wild-color-indicator {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.7);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .player-hand {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 160px;
        padding: 10px;
        border-radius: 15px;
        transition: all 0.3s;
    }

    .player-hand.your-turn {
        animation: glowPulse 2s ease-in-out infinite;
        box-shadow: 0 0 20px rgba(46, 204, 113, 0.6),
                    0 0 40px rgba(46, 204, 113, 0.4),
                    0 0 60px rgba(46, 204, 113, 0.2);
    }

    @keyframes glowPulse {
        0%, 100% {
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.6),
                        0 0 40px rgba(46, 204, 113, 0.4),
                        0 0 60px rgba(46, 204, 113, 0.2);
        }
        50% {
            box-shadow: 0 0 30px rgba(46, 204, 113, 0.8),
                        0 0 60px rgba(46, 204, 113, 0.6),
                        0 0 90px rgba(46, 204, 113, 0.4);
        }
    }

    .player-hand .card {
        width: 80px;
        height: 120px;
    }

    .player-hand .card-inner {
        font-size: 1.6em;
    }

    .card.disabled {
        opacity: 0.42;
        cursor: not-allowed;
        filter: grayscale(25%);
    }

    /* Jump-in card highlight */
    .card.jump-in-card {
        opacity: 1 !important;
        filter: none !important;
        cursor: pointer !important;
        animation: jumpInPulse 0.9s ease-in-out infinite;
        outline: 3px solid #f1c40f;
        outline-offset: 3px;
        box-shadow: 0 0 18px rgba(241, 196, 15, 0.9),
                    0 0 35px rgba(241, 196, 15, 0.5) !important;
        z-index: 5;
        position: relative;
    }

    @keyframes jumpInPulse {
        0%, 100% {
            box-shadow: 0 0 18px rgba(241, 196, 15, 0.9), 0 0 35px rgba(241, 196, 15, 0.5);
            transform: translateY(0) scale(1);
        }
        50% {
            box-shadow: 0 0 28px rgba(241, 196, 15, 1), 0 0 55px rgba(241, 196, 15, 0.8);
            transform: translateY(-8px) scale(1.06);
        }
    }

    /* Jump-in banner */
    #jumpInBanner {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.7);
        background: linear-gradient(135deg, #f1c40f, #f39c12);
        color: #1a1a1a;
        font-family: 'Orbitron', sans-serif;
        font-weight: 900;
        font-size: 1.05em;
        padding: 12px 28px;
        border-radius: 40px;
        box-shadow: 0 8px 32px rgba(241, 196, 15, 0.7), 0 0 0 3px rgba(255,255,255,0.3);
        z-index: 50;
        pointer-events: none;
        letter-spacing: 1.5px;
        text-align: center;
        opacity: 0;
        transition: none;
    }

    #jumpInBanner.visible {
        display: block;
        animation: jumpInBannerIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                   jumpInBannerBob 1.4s ease-in-out 0.4s infinite;
    }

    #jumpInBanner.hiding {
        display: block;
        animation: jumpInBannerOut 0.25s ease-in forwards;
    }

    @keyframes jumpInBannerIn {
        from { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        to   { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes jumpInBannerBob {
        0%, 100% { transform: translate(-50%, -50%) scale(1) translateY(0); }
        50%       { transform: translate(-50%, -60%) scale(1.04); }
    }

    @keyframes jumpInBannerOut {
        from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        to   { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
    }

    .message {
        text-align: center;
        color: var(--text-on-glass);
        font-size: 1.3em;
        margin: 15px 0;
        min-height: 35px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .color-picker {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--surface);
        padding: 30px;
        border-radius: 20px;
        box-shadow: var(--menu-shadow);
        z-index: 1000;
        color: var(--text-primary);
        transition: background 0.3s;
    }

    .color-picker.active {
        display: block;
    }

    .color-picker h3 {
        color: var(--text-primary);
    }

    .color-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        margin-top: 15px;
    }

    .color-option {
        width: 80px;
        height: 80px;
        border-radius: 10px;
        cursor: pointer;
        border: 4px solid #fff;
        transition: transform 0.2s;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        touch-action: manipulation;
    }

    .color-option:active {
        transform: scale(0.9);
    }

    .color-option.red { 
        background-color: #e74c3c !important;
        background: #e74c3c !important;
    }
    .color-option.blue { 
        background-color: #3498db !important;
        background: #3498db !important;
    }
    .color-option.green { 
        background-color: #2ecc71 !important;
        background: #2ecc71 !important;
    }
    .color-option.yellow { 
        background-color: #f1c40f !important;
        background: #f1c40f !important;
    }

    /* Swap target picker */
    .swap-picker {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.85);
        background: var(--surface);
        padding: 28px 32px;
        border-radius: 20px;
        box-shadow: var(--menu-shadow);
        z-index: 1001;
        color: var(--text-primary);
        min-width: 280px;
        max-width: 92vw;
        opacity: 0;
        transition: opacity 0.2s, transform 0.25s cubic-bezier(0.34,1.56,0.64,1);
    }

    .swap-picker.active {
        display: block;
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }

    .swap-picker-title {
        font-size: 1.1em;
        font-weight: 800;
        color: var(--text-primary);
        margin-bottom: 18px;
        text-align: center;
    }

    .swap-options {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .swap-option-btn {
        padding: 13px 20px;
        border-radius: 12px;
        border: 2px solid rgba(102,126,234,0.35);
        background: rgba(102,126,234,0.12);
        color: var(--text-primary);
        font-size: 1.05em;
        font-weight: 700;
        cursor: pointer;
        text-align: center;
        transition: background 0.15s, transform 0.15s, border-color 0.15s;
        font-family: 'Nunito', sans-serif;
    }

    .swap-option-btn:hover, .swap-option-btn:active {
        background: rgba(102,126,234,0.32);
        border-color: rgba(102,126,234,0.8);
        transform: scale(1.03);
    }

    .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 999;
    }

    .overlay.active {
        display: block;
    }

    /* Custom Popup Styles */
    .custom-popup {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--popup-bg);
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        z-index: 1001;
        box-shadow: var(--menu-shadow);
        max-width: 90%;
        min-width: 300px;
        color: var(--popup-text);
        animation: popupFadeIn 0.3s ease-out;
        transition: background 0.3s, color 0.3s;
    }

    .custom-popup.active {
        display: block;
    }

    @keyframes popupFadeIn {
        from {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
        }
        to {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    }

    .custom-popup h2 {
        font-size: 2em;
        margin-bottom: 20px;
        color: var(--menu-h1);
    }

    .custom-popup p {
        font-size: 1.2em;
        margin-bottom: 30px;
        color: var(--popup-sub);
        line-height: 1.5;
    }

    .popup-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
    }

    .popup-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 1.1em;
        font-weight: 600;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 6px 15px rgba(102, 126, 234, 0.4);
        touch-action: manipulation;
        min-width: 120px;
    }

    .popup-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.5);
    }

    .popup-button:active {
        transform: translateY(0);
        box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);
    }

    .popup-button.secondary {
        background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        box-shadow: 0 6px 15px rgba(149, 165, 166, 0.4);
    }

    .popup-button.secondary:hover {
        box-shadow: 0 8px 20px rgba(149, 165, 166, 0.5);
    }

    .loading {
        text-align: center;
        color: white;
        font-size: 1.5em;
        padding: 20px;
    }

    .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid white;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .uno-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        border: 3px solid rgba(255,255,255,0.3);
        padding: 15px 30px;
        font-size: 1.3em;
        font-weight: 900;
        border-radius: 50px;
        cursor: pointer;
        box-shadow: 0 6px 20px rgba(231, 76, 60, 0.5);
        display: none;
        z-index: 100;
        touch-action: manipulation;
        letter-spacing: 1px;
    }

    .uno-button.active {
        display: block;
        animation: unoBtnPulse 0.8s ease-in-out infinite;
    }

    @keyframes unoBtnPulse {
        0%, 100% { transform: scale(1);    box-shadow: 0 6px 20px rgba(231,76,60,0.5); }
        50%       { transform: scale(1.07); box-shadow: 0 8px 30px rgba(231,76,60,0.9); }
    }

    /* =============================================
       DARK MODE TOGGLE BUTTON
    ============================================= */
    #darkModeToggle {
        position: fixed;
        top: 16px;
        right: 16px;
        z-index: 9000;
        width: 48px;
        height: 28px;
        border-radius: 14px;
        border: none;
        cursor: pointer;
        background: var(--surface-glass-strong);
        backdrop-filter: blur(8px);
        border: 1.5px solid rgba(255,255,255,0.25);
        display: flex;
        align-items: center;
        padding: 3px;
        transition: background 0.3s, border-color 0.3s;
        box-shadow: 0 2px 12px rgba(0,0,0,0.25);
    }

    #darkModeToggle:hover { opacity: 0.85; }

    #darkModeToggle .toggle-knob {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: white;
        transition: transform 0.3s cubic-bezier(0.34,1.56,0.64,1), background 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        box-shadow: 0 1px 6px rgba(0,0,0,0.35);
    }

    html[data-theme="dark"] #darkModeToggle {
        background: rgba(140,100,255,0.25);
        border-color: rgba(140,100,255,0.4);
    }

    html[data-theme="dark"] #darkModeToggle .toggle-knob {
        transform: translateX(20px);
        background: #a78bfa;
    }

    .controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
        flex-wrap: wrap;
    }

    .controls button {
        padding: 12px 25px;
        font-size: 1em;
        background-color: #667eea;
        background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        touch-action: manipulation;
        font-weight: 600;
        -webkit-appearance: none;
    }

    .controls button:active {
        transform: translateY(2px);
    }

    /* Waiting Lobby Enhancements */
    .lobby-header {
        background: var(--lobby-header-bg);
        backdrop-filter: blur(10px);
        padding: 15px 20px;
        border-radius: 12px;
        margin-bottom: 20px;
        text-align: center;
        color: var(--text-primary);
    }

    .lobby-id {
        font-size: 0.9em;
        color: var(--lobby-id-color);
        font-family: monospace;
        margin-top: 5px;
    }

    .player-slot {
        padding: 12px 15px;
        background: var(--surface-slot);
        border-radius: 10px;
        display: flex;
        align-items: center;
        gap: 12px;
        transition: all 0.3s ease;
        border: 2px solid transparent;
        color: var(--text-primary);
    }

    .player-slot.you {
        background: var(--surface-slot-you);
        border: 2px solid rgba(102, 126, 234, 0.5);
        box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        color: var(--text-primary);
    }

    .player-slot.empty {
        background: var(--surface-slot-empty);
        border: 2px dashed rgba(255, 255, 255, 0.2);
        color: var(--text-muted);
    }

    .player-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3em;
        flex-shrink: 0;
    }

    .player-avatar.empty {
        background: rgba(255, 255, 255, 0.1);
        opacity: 0.5;
    }

    .player-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 3px;
    }

    .player-name {
        font-weight: 600;
        font-size: 1.05em;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .host-badge {
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        padding: 2px 8px;
        border-radius: 5px;
        font-size: 0.75em;
        font-weight: bold;
    }

    .player-ready-status {
        font-size: 0.9em;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .ready-badge {
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 0.85em;
        font-weight: bold;
        text-align: center;
        min-width: 80px;
    }

    .ready-badge.ready {
        background: rgba(46, 204, 113, 0.25);
        color: #2ecc71;
        border: 1px solid rgba(46, 204, 113, 0.4);
    }

    .ready-badge.not-ready {
        background: rgba(243, 156, 18, 0.25);
        color: #f39c12;
        border: 1px solid rgba(243, 156, 18, 0.4);
    }

    .ready-badge.empty {
        background: rgba(255, 255, 255, 0.05);
        color: #95a5a6;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .rules-container {
        background: var(--rules-bg);
        backdrop-filter: blur(10px);
        padding: 18px;
        border-radius: 12px;
        margin: 20px 0;
        color: var(--text-primary);
    }

    .rules-section {
        margin-bottom: 15px;
    }

    .rules-section:last-child {
        margin-bottom: 0;
    }

    .rules-title {
        font-weight: 700;
        font-size: 1.05em;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--text-primary);
    }

    .rule-item {
        background: var(--surface-rule-item);
        padding: 8px 12px;
        border-radius: 8px;
        margin: 6px 0;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95em;
        color: var(--text-primary);
    }

    .ready-status-bar {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(10px);
        padding: 12px 18px;
        border-radius: 10px;
        margin: 15px 0;
        text-align: center;
        font-size: 1em;
        font-weight: 600;
    }

    .ready-status-bar.all-ready {
        background: rgba(46, 204, 113, 0.25);
        color: #2ecc71;
        border: 2px solid rgba(46, 204, 113, 0.4);
        animation: pulse 1.5s ease-in-out infinite;
    }

    .ready-status-bar.waiting {
        background: rgba(243, 156, 18, 0.25);
        color: #f39c12;
        border: 2px solid rgba(243, 156, 18, 0.4);
    }

    @keyframes pulse {
        0%, 100% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.02);
            opacity: 0.9;
        }
    }

    @keyframes readyPulse {
        0%, 100% {
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }
        50% {
            box-shadow: 0 4px 25px rgba(46, 204, 113, 0.7);
        }
    }

    #readyButton {
        animation: readyPulse 2s ease-in-out infinite;
        font-size: 1.1em;
        padding: 15px 30px;
        font-weight: 700;
    }

    #readyButton.is-ready {
        animation: none;
    }

    .waiting-message {
        font-size: 0.95em;
        color: rgba(0, 0, 0, 0.8);
        text-align: center;
        margin: 10px 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .spinner {
        display: inline-block;
        animation: spin 1s linear infinite;
    }

    @media (max-width: 768px) {
        h1 { font-size: 2.5em; }
        h2 { font-size: 1.5em; }
        .menu-container { padding: 30px 20px; }
        .card { width: 80px; height: 120px; }
        .card-inner { font-size: 1.6em; }
        .player-hand .card { width: 65px; height: 100px; }
        .player-hand .card-inner { font-size: 1.3em; }
        .player-avatar { width: 35px; height: 35px; font-size: 1.1em; }
        .player-name { font-size: 0.95em; }
        .ready-badge { min-width: 70px; font-size: 0.8em; }
    }

    /* ============================================
       DRAW PENALTY ANIMATION SYSTEM (+2 / +4)
    ============================================ */

    /* Flying card from deck to opponent/player */
    .draw-penalty-card {
        position: fixed;
        z-index: 9998;
        width: 55px;
        height: 82px;
        border-radius: 8px;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        border: 2px solid rgba(255,255,255,0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.4em;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5), 0 0 15px rgba(255,200,0,0.3);
        pointer-events: none;
        transition:
            left 0.55s cubic-bezier(0.2, 0.8, 0.2, 1),
            top 0.55s cubic-bezier(0.2, 0.8, 0.2, 1),
            transform 0.55s cubic-bezier(0.34, 1.2, 0.64, 1),
            opacity 0.3s ease;
        will-change: left, top, transform;
    }

    /* Burst effect that appears on the victim */
    @keyframes penaltyBurst {
        0%   { transform: scale(0.5) rotate(-10deg); opacity: 0; }
        40%  { transform: scale(1.3) rotate(4deg);  opacity: 1; }
        70%  { transform: scale(0.95) rotate(-2deg); opacity: 1; }
        100% { transform: scale(1) rotate(0deg);    opacity: 0; }
    }

    .penalty-burst {
        position: fixed;
        z-index: 9999;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        animation: penaltyBurst 1.1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
    }

    .penalty-burst-badge {
        background: linear-gradient(135deg, #ff416c, #ff4b2b);
        color: white;
        font-weight: 900;
        font-size: 1.5em;
        padding: 6px 18px;
        border-radius: 30px;
        box-shadow: 0 4px 20px rgba(255,65,108,0.7), 0 0 30px rgba(255,75,43,0.4);
        letter-spacing: 1px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        white-space: nowrap;
    }

    .penalty-burst-sub {
        color: white;
        font-size: 0.95em;
        font-weight: 700;
        text-shadow: 0 2px 8px rgba(0,0,0,0.8);
        background: rgba(0,0,0,0.5);
        padding: 3px 12px;
        border-radius: 12px;
    }

    /* Victim box shake */
    @keyframes victimShake {
        0%   { transform: translateX(0)   rotate(0deg); }
        15%  { transform: translateX(-8px) rotate(-3deg); }
        30%  { transform: translateX(8px)  rotate(3deg); }
        45%  { transform: translateX(-6px) rotate(-2deg); }
        60%  { transform: translateX(6px)  rotate(2deg); }
        75%  { transform: translateX(-4px) rotate(-1deg); }
        90%  { transform: translateX(4px)  rotate(1deg); }
        100% { transform: translateX(0)   rotate(0deg); }
    }

    .victim-shaking {
        animation: victimShake 0.55s ease-in-out;
        border-color: #ff416c !important;
        box-shadow: 0 0 25px rgba(255,65,108,0.8) !important;
    }

    /* Screen flash for the victim player's own view */
    @keyframes screenFlash {
        0%   { opacity: 0; }
        20%  { opacity: 0.45; }
        60%  { opacity: 0.2; }
        100% { opacity: 0; }
    }

    #penaltyFlash {
        position: fixed;
        inset: 0;
        z-index: 9997;
        background: radial-gradient(ellipse at center, rgba(255,65,108,0.6) 0%, rgba(255,75,43,0.3) 60%, transparent 100%);
        pointer-events: none;
        opacity: 0;
        display: none;
    }

    #penaltyFlash.flashing {
        display: block;
        animation: screenFlash 0.7s ease-out forwards;
    }

    /* Card trail sparkle */
    @keyframes sparkle {
        0%   { transform: scale(0) rotate(0deg); opacity: 1; }
        100% { transform: scale(1.5) rotate(180deg); opacity: 0; }
    }

    .card-sparkle {
        position: fixed;
        z-index: 9997;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        pointer-events: none;
        animation: sparkle 0.4s ease-out forwards;
    }
    .card-fly-to-center,
    .card-fly-to-hand {
        position: fixed;
        z-index: 9999;
        transition: 
            left 0.6s cubic-bezier(0.2, 0.8, 0.2, 1),
            top 0.6s cubic-bezier(0.2, 0.8, 0.2, 1),
            transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1),
            opacity 0.6s ease-out;
        pointer-events: none;
    }

    /* Landing bounce animation */
    @keyframes cardLand {
        0% {
            transform: scale(1.1) rotate(0deg);
        }
        50% {
            transform: scale(1.15) rotate(0deg);
        }
        100% {
            transform: scale(1) rotate(0deg);
        }
    }

    /* Discard pile pulse animation */
    @keyframes discardLand {
        0% {
            transform: scale(1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        50% {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 255, 0.3);
        }
        100% {
            transform: scale(1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
    }

    /* Card just played impact effect */
    @keyframes cardJustPlayed {
        0% {
            transform: scale(1.05);
        }
        100% {
            transform: scale(1);
        }
    }

    .card-just-played {
        animation: cardJustPlayed 0.3s ease-out;
    }

    .discard-pile-pulse {
        animation: discardLand 0.3s ease-out;
    }

    .stack-indicator {
        display: none;
        background: linear-gradient(135deg, #ff416c, #ff4b2b);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.9em;
        text-align: center;
        box-shadow: 0 4px 15px rgba(255, 65, 108, 0.5);
        animation: stackPulse 1.5s ease-in-out infinite;
        white-space: nowrap;
        position: relative;
        overflow: visible;
    }

    .stack-indicator.active {
        display: block;
    }

    .stack-indicator.stack-bump {
        animation: stackBump 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), stackPulse 1.5s ease-in-out infinite 0.4s;
    }

    @keyframes stackPulse {
        0%, 100% { transform: scale(1); box-shadow: 0 4px 15px rgba(255, 65, 108, 0.5); }
        50%       { transform: scale(1.06); box-shadow: 0 6px 25px rgba(255, 65, 108, 0.8); }
    }

    @keyframes stackBump {
        0%   { transform: scale(1); }
        40%  { transform: scale(1.35); box-shadow: 0 8px 35px rgba(255, 65, 108, 1); }
        100% { transform: scale(1); }
    }

    .stack-count-num {
        display: inline-block;
        font-size: 1.6em;
        font-weight: 900;
        font-family: 'Orbitron', sans-serif;
        line-height: 1;
        transition: color 0.15s;
    }

    .stack-count-num.num-change {
        animation: numPop 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes numPop {
        0%   { transform: scale(1) translateY(0); color: white; }
        50%  { transform: scale(1.5) translateY(-4px); color: #ffe082; }
        100% { transform: scale(1) translateY(0); color: white; }
    }

    .stack-increment-badge {
        position: absolute;
        top: -28px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.25);
        color: white;
        font-size: 1em;
        font-weight: 900;
        font-family: 'Orbitron', sans-serif;
        border-radius: 10px;
        padding: 2px 10px;
        pointer-events: none;
        animation: incrementFloat 0.9s ease-out forwards;
        white-space: nowrap;
    }

    @keyframes incrementFloat {
        0%   { opacity: 1; transform: translateX(-50%) translateY(0) scale(0.8); }
        60%  { opacity: 1; transform: translateX(-50%) translateY(-20px) scale(1.1); }
        100% { opacity: 0; transform: translateX(-50%) translateY(-36px) scale(0.9); }
    }

    /* Disconnect Notification Styles */
    .disconnect-notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
        color: white;
        padding: 15px 25px;
        border-radius: 12px;
        font-weight: 600;
        font-size: 1em;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 10000;
        display: none;
        animation: slideDown 0.3s ease-out;
        max-width: 90%;
        text-align: center;
    }

    .disconnect-notification.active {
        display: block;
    }

    .disconnect-notification.reconnected {
        background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
    }

    @keyframes slideDown {
        from {
            transform: translateX(-50%) translateY(-100%);
            opacity: 0;
        }
        to {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
    }

    .disconnect-notification .reconnect-timer {
        display: block;
        font-size: 0.9em;
        margin-top: 5px;
        opacity: 0.9;
    }

    /* Player connection status indicator */
    .player-connection-status {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 5px;
        background: #51cf66;
    }

    .player-connection-status.disconnected {
        background: #ff6b6b;
        animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }

    /* Minimum players warning */
    .min-players-warning {
        background: rgba(255, 152, 0, 0.15);
        border: 2px solid #ff9800;
        border-radius: 10px;
        padding: 12px;
        margin: 10px 0;
        color: #f57c00;
        font-weight: 600;
        text-align: center;
    }
</style>

</head>
<body>
    <!-- Disconnect Notification -->
    <div id="disconnectNotification" class="disconnect-notification"></div>

    <!-- Main Menu -->
    <div id="mainMenu" class="screen active">
        <div class="menu-container">
            <h1>🎴 O,No 🎴</h1>
            <p style="margin-bottom: 30px; color: var(--text-muted);">Choose Game Mode</p>
            <button class="menu-button online" onclick="showOnlineMenu()">🌐 Play Online</button>
            <button class="menu-button offline" onclick="playOffline()">🤖 Play vs Computer</button>
        </div>
    </div>


<!-- Online Menu -->
<div id="onlineMenu" class="screen">
    <div class="menu-container">
        <h2>🌐 Online Multiplayer</h2>
        <p style="margin-bottom: 30px; color: var(--text-muted);">Choose an option</p>
        <button class="menu-button create" onclick="showCreateLobby()">➕ Create Lobby</button>
        <button class="menu-button online" onclick="showLobbyList()">🎮 Join Lobby</button>
        <button class="menu-button offline" onclick="showMainMenu()">Back to Menu</button>
    </div>
</div>

<!-- Lobby List -->
<div id="lobbyList" class="screen">
    <div class="menu-container">
        <h2>🎮 Available Lobbies</h2>
        <p style="margin-bottom: 20px; color: var(--text-muted);">Select a lobby to join</p>
        
        <div class="lobby-list" id="lobbyListContainer">
            <!-- Lobbies will be dynamically added here -->
        </div>

        <button class="menu-button" onclick="refreshLobbies()" style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);">🔄 Refresh</button>
        <button class="menu-button offline" onclick="showOnlineMenu()">Back</button>
    </div>
</div>

<!-- Create Lobby -->
<div id="createLobby" class="screen">
    <div class="menu-container">
        <h2>Create Lobby</h2>
        
        <div class="setting-item">
            <label>Your Name</label>
            <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
        </div>

        <div class="setting-item">
            <label>Lobby Name</label>
            <input type="text" id="lobbyName" placeholder="Enter lobby name" maxlength="30">
        </div>

        <div class="setting-item">
            <label>Number of Players</label>
            <select id="maxPlayers">
                <option value="2">2 Players (1v1)</option>
                <option value="3" selected>3 Players (1v1v1)</option>
                <option value="4">4 Players</option>
                <option value="5">5 Players</option>
                <option value="6">6 Players</option>
                <option value="7">7 Players</option>
                <option value="8">8 Players</option>
            </select>
        </div>

        <div class="setting-item">
            <label>Starting Cards</label>
            <select id="startingCards">
                <option value="5">5 Cards</option>
                <option value="7" selected>7 Cards</option>
                <option value="10">10 Cards</option>
            </select>
        </div>

        <div class="setting-item">
            <label style="margin-bottom: 15px;">Game Rules</label>
            
            <div class="toggle-container">
                <label style="margin: 0;">Allow +2/+4 Stacking</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="allowStacking">
                    <span class="slider-toggle"></span>
                </label>
            </div>
            <p style="font-size: 0.9em; color: var(--text-muted); margin-bottom: 10px;">Stack draw cards to pass the penalty</p>
            
            <div class="toggle-container">
                <label style="margin: 0;">💀 Allow +12 Card</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="allowPlus12">
                    <span class="slider-toggle"></span>
                </label>
            </div>
            <p style="font-size: 0.9em; color: var(--text-muted); margin-bottom: 10px;">Adds 2 rare +12 wild cards to the deck — low chance, devastating effect</p>
            
            <div class="toggle-container">
                <label style="margin: 0;">Allow Jump-In</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="allowJumpIn">
                    <span class="slider-toggle"></span>
                </label>
            </div>
            <p style="font-size: 0.9em; color: var(--text-muted); margin-bottom: 10px;">Play out of turn with exact match</p>
            
            <div class="toggle-container">
                <label style="margin: 0;">Draw Until Match</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="drawUntilMatch" checked>
                    <span class="slider-toggle"></span>
                </label>
            </div>
            <p style="font-size: 0.9em; color: var(--text-muted);">Keep drawing cards until a playable card is found. When off, draw only one card per turn.</p>
        </div>

        <div class="setting-item">
            <label>Lobby Visibility</label>
            <div class="toggle-container">
                <label style="margin: 0;">🔒 Private Lobby</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="isPrivate" onchange="togglePasscodeField()">
                    <span class="slider-toggle"></span>
                </label>
            </div>
            <p style="font-size: 0.9em; color: var(--text-muted); margin-bottom: 10px;">Private lobbies require a passcode to join</p>

            <div id="passcodeField" style="display:none; margin-top: 8px;">
                <input type="text" id="lobbyPasscode" placeholder="Enter passcode (4–12 chars)" maxlength="12" style="margin-bottom:0; letter-spacing: 3px; font-weight: 700;">
            </div>
        </div>

        <button class="menu-button online" onclick="createLobby()">Create Lobby</button>
        <button class="menu-button offline" onclick="showOnlineMenu()">Back</button>
    </div>
</div>

<!-- Waiting in Lobby -->
<div id="waitingLobby" class="screen">
    <div class="menu-container">
        <h2>⏳ Waiting in Lobby</h2>
        <div class="loading">
            <!-- Lobby Header with Name and ID -->
            <div class="lobby-header">
                <p id="waitingLobbyName" style="font-size: 1.4em; font-weight: 700; margin-bottom: 5px; color: var(--text-primary);">Lobby Name</p>
                <p class="lobby-id" id="lobbyIdDisplay">Lobby ID: ••••••</p>
                <p style="font-size: 1.05em; margin-top: 10px; color: rgba(0, 0, 0, 0.9);">
                    <span id="playerCountText">1 / 2</span> Players
                </p>
            </div>

            <!-- Ready Status Bar -->
            <div id="readyStatusBar" class="ready-status-bar waiting" style="display: none;">
                <!-- Dynamic ready status message -->
            </div>

            <!-- Waiting Message -->
            <div id="waitingMessage" class="waiting-message" style="display: none;">
                <span class="spinner">⏳</span>
                <span>Waiting for more players to join...</span>
            </div>
            
            <!-- Players Status -->
            <div id="playersStatus" style="background: var(--surface-inset); backdrop-filter: blur(10px); padding: 15px; border-radius: 12px; margin-bottom: 20px; max-height: 350px; overflow-y: auto; color: var(--text-primary);">
                <!-- Player status will be dynamically added here -->
            </div>

            <!-- Rules Display -->
            <div id="waitingRules">
                <!-- Rules will be displayed here -->
            </div>
        </div>
        <button class="menu-button online" id="readyButton" onclick="toggleReady()" style="display: none;">✓ Ready Up!</button>
        <button class="menu-button offline" onclick="leaveLobby()">Leave Lobby</button>
    </div>
</div>

<!-- Game Screen -->
<div id="gameScreen" class="screen">
    <div class="game-table-wrapper">

        <!-- Top info bar -->
        <div class="game-info">
            <div>🎨 <span id="currentColor">-</span></div>
            <div>🃏 Deck: <span id="deckCount">-</span></div>
            <div id="stackIndicator" class="stack-indicator"></div>
        </div>

        <!-- Oval table arena -->
        <div class="table-arena" id="tableArena">
        <!-- Direction indicator SVG injected by JS -->
        <svg id="directionSvg" class="direction-svg" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <marker id="arrowHead" markerWidth="9" markerHeight="9" refX="7" refY="3" orient="auto">
                    <path d="M0,0 L0,6 L9,3 z" fill="rgba(255,255,255,0.9)"/>
                </marker>
            </defs>
            <!-- Full oval track (faint) -->
            <ellipse cx="200" cy="150" rx="175" ry="128" fill="none"
                     stroke="rgba(255,255,255,0.12)" stroke-width="1.5"/>
            <!-- Animated travelling arc CW -->
            <ellipse id="arcCW" cx="200" cy="150" rx="175" ry="128" fill="none"
                     stroke="rgba(255,255,255,0.7)" stroke-width="3"
                     stroke-dasharray="55 1060" stroke-dashoffset="0"
                     marker-end="url(#arrowHead)"
                     class="dir-arc">
                <animate attributeName="stroke-dashoffset"
                         from="0" to="-1115"
                         dur="3s" repeatCount="indefinite"/>
            </ellipse>
            <!-- Animated travelling arc CCW -->
            <ellipse id="arcCCW" cx="200" cy="150" rx="175" ry="128" fill="none"
                     stroke="rgba(255,255,255,0.7)" stroke-width="3"
                     stroke-dasharray="55 1060" stroke-dashoffset="0"
                     marker-end="url(#arrowHead)"
                     class="dir-arc" style="display:none"
                     transform="scale(-1,1) translate(-400,0)">
                <animate id="animCCW" attributeName="stroke-dashoffset"
                         from="0" to="-1115"
                         dur="3s" repeatCount="indefinite"/>
            </ellipse>
        </svg>

            <!-- Play area center -->
            <div class="play-area" id="playArea">
                <div class="card card-back" id="drawPile" onclick="drawCard()" style="cursor:pointer;">
                    <div class="card-inner" style="font-size:0.6em;color:rgba(255,255,255,0.7);background:rgba(255,255,255,0.08);font-family:'Orbitron',sans-serif;letter-spacing:1px;">DRAW</div>
                </div>
                <div id="discardPile"></div>
            </div>

            <!-- Player seats injected by JS -->
            <div id="tableSeats"></div>
        </div>

        <!-- Message bar -->
        <div class="message" id="message">Waiting for game to start...</div>

        <!-- Your hand -->
        <div class="player-hand" id="playerHand"></div>

        <div class="controls">
            <button onclick="leaveGame()">Leave Game</button>
        </div>
    </div>
</div>

<div id="penaltyFlash"></div>

<!-- Jump-In Banner -->
<div id="jumpInBanner">⚡ JUMP IN!</div>

<!-- Dark Mode Toggle -->
<button id="darkModeToggle" onclick="toggleDarkMode()" title="Toggle dark mode" aria-label="Toggle dark mode">
    <div class="toggle-knob">☀️</div>
</button>

<button class="uno-button" id="unoButton" onclick="callUno()">O,NO!</button>

<div class="overlay" id="overlay"></div>

<div class="color-picker" id="colorPicker">
    <h3>Choose a Color:</h3>
    <div class="color-options">
        <div class="color-option red" onclick="chooseColor('red')"></div>
        <div class="color-option blue" onclick="chooseColor('blue')"></div>
        <div class="color-option green" onclick="chooseColor('green')"></div>
        <div class="color-option yellow" onclick="chooseColor('yellow')"></div>
    </div>
</div>

<!-- 7-Swap target picker -->
<div class="swap-picker" id="swapPicker">
    <div class="swap-picker-title">🔄 Choose who to swap hands with</div>
    <div class="swap-options" id="swapOptions"></div>
</div>

<div class="custom-popup" id="customPopup">
    <h2 id="popupTitle"></h2>
    <p id="popupMessage"></p>
    <div class="popup-buttons" id="popupButtons"></div>
</div>

<script src="/js/playerPresence.js"></script>
<script>
    let socket;
    let gameState = null;
    let prevStackCount = 0;
    let roomId = null;
    let pendingCardIndex = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    let currentLobbies = [];
    let isReady = false;
    let currentLobbyData = null;
    let isWaitingForServer = false;
    let heartbeatInterval = null;
    let disconnectNotificationTimeout = null;

    // =============================================
    //  DARK MODE
    // =============================================
    (function initTheme() {
        const saved = localStorage.getItem('ono-theme') || 'light';
        applyTheme(saved);
    })();

    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        const knob = document.querySelector('#darkModeToggle .toggle-knob');
        if (knob) knob.textContent = theme === 'dark' ? '🌙' : '☀️';
    }

    function toggleDarkMode() {
        const current = document.documentElement.getAttribute('data-theme') || 'light';
        const next = current === 'dark' ? 'light' : 'dark';
        localStorage.setItem('ono-theme', next);
        applyTheme(next);
    }
    // Background animation settings
    function loadBackgroundAnimation() {
        const savedAnimation = localStorage.getItem('onoBackgroundAnimation');
        const validAnimations = ['static', 'color-cycle', 'pulsing'];
        const animation = validAnimations.includes(savedAnimation) ? savedAnimation : 'static';
        applyBackgroundAnimation(animation);
    }

    function applyBackgroundAnimation(animation) {
        const classMap = {
            'static': 'bg-static',
            'color-cycle': 'bg-color-cycle',
            'pulsing': 'bg-pulsing'
        };
        
        const className = classMap[animation] || 'bg-static';
        
        const body = document.body;
        body.classList.remove('bg-static', 'bg-color-cycle', 'bg-pulsing');
        body.classList.add(className);
    }

    // Custom Popup Functions
    function showPopup(message, title = '') {
        const popup = document.getElementById('customPopup');
        const overlay = document.getElementById('overlay');
        const popupTitle = document.getElementById('popupTitle');
        const popupMessage = document.getElementById('popupMessage');
        const popupButtons = document.getElementById('popupButtons');

        // Set title and message
        if (title) {
            popupTitle.textContent = title;
            popupTitle.style.display = 'block';
        } else {
            popupTitle.style.display = 'none';
        }
        popupMessage.textContent = message;

        // Clear and create OK button
        popupButtons.innerHTML = '';
        const okButton = document.createElement('button');
        okButton.className = 'popup-button';
        okButton.textContent = 'OK';
        okButton.onclick = () => {
            popup.classList.remove('active');
            overlay.classList.remove('active');
        };
        popupButtons.appendChild(okButton);

        // Show popup and overlay
        overlay.classList.add('active');
        popup.classList.add('active');
    }

    function showConfirm(message, callback, title = 'Confirm') {
        const popup = document.getElementById('customPopup');
        const overlay = document.getElementById('overlay');
        const popupTitle = document.getElementById('popupTitle');
        const popupMessage = document.getElementById('popupMessage');
        const popupButtons = document.getElementById('popupButtons');

        // Set title and message
        popupTitle.textContent = title;
        popupTitle.style.display = 'block';
        popupMessage.textContent = message;

        // Clear and create Yes/No buttons
        popupButtons.innerHTML = '';
        
        const noButton = document.createElement('button');
        noButton.className = 'popup-button secondary';
        noButton.textContent = 'No';
        noButton.onclick = () => {
            popup.classList.remove('active');
            overlay.classList.remove('active');
            if (callback) callback(false);
        };

        const yesButton = document.createElement('button');
        yesButton.className = 'popup-button';
        yesButton.textContent = 'Yes';
        yesButton.onclick = () => {
            popup.classList.remove('active');
            overlay.classList.remove('active');
            if (callback) callback(true);
        };

        popupButtons.appendChild(noButton);
        popupButtons.appendChild(yesButton);

        // Show popup and overlay
        overlay.classList.add('active');
        popup.classList.add('active');
    }

    // Initialize socket connection with error handling
    function initializeSocket() {
        try {
            socket = io({
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: MAX_RECONNECT_ATTEMPTS
            });

            setupSocketListeners();
        } catch (error) {
            console.error('Socket initialization error:', error);
            showPopup('Failed to connect to server. Please refresh the page.');
        }
    }

    function setupSocketListeners() {
        socket.on('connect', () => {
            console.log('Connected to server');
            reconnectAttempts = 0;
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
        });

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            reconnectAttempts++;
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                showPopup('Unable to connect to server. Please check your internet connection and refresh the page.');
            }
        });

        socket.on('lobbyList', (lobbies) => {
            currentLobbies = lobbies;
            renderLobbyList();
        });

        socket.on('lobbyCreated', (data) => {
            roomId = data.roomId;
            currentLobbyData = data;
            isReady = false;
            startHeartbeat(); // Start heartbeat in lobby
            showWaitingLobby(data.lobbyName, data.settings, data.players, data.minPlayers || 2);
        });

        socket.on('lobbyJoined', (data) => {
            roomId = data.roomId;
            currentLobbyData = data;
            isReady = false;
            startHeartbeat(); // Start heartbeat in lobby
            showWaitingLobby(data.lobbyName, data.settings, data.players, data.minPlayers || 2);
        });

        socket.on('lobbyUpdate', (data) => {
            if (roomId === data.roomId) {
                currentLobbyData = data;
                updateLobbyStatus(data.players);
            }
        });

        socket.on('gameStarted', (state) => {
            gameState = state;
            isWaitingForServer = false;
            showScreen('gameScreen');
            // Start heartbeat monitoring for in-game presence
            startHeartbeat();
            // Explicitly set the initial game message based on whose turn it is
            if (gameState.isYourTurn) {
                showMessage('Your turn!');
            } else {
                showMessage(gameState.currentPlayerName ? `${gameState.currentPlayerName}'s turn...` : "Opponent's turn...");
            }
            updateGameUI();
        });

        socket.on('gameState', (state) => {
            // Always reset waiting flag when server responds — prevents getting stuck
            isWaitingForServer = false;
            
            // Show animation if cards were drawn by the current player
            if (state.lastDrawInfo && state.lastDrawInfo.cardsDrawn && state.lastDrawInfo.playerId === socket.id) {
                const count = state.lastDrawInfo.cardsDrawn;
                
                // Animate the cards being drawn
                if (count === 1) {
                    // Single card animation
                    animateCardToHand('player', () => {
                        // Update game state after animation completes
                        gameState = state;
                        isWaitingForServer = false;
                        
                        const message = 'You drew a card!';
                        showMessage(message);
                        updateGameUI();
                    });
                } else {
                    // Multiple cards with staggered animation
                    animateMultipleCardsToHand(count, () => {
                        // Update game state after all animations complete
                        gameState = state;
                        isWaitingForServer = false;
                        
                        const message = `You drew ${count} cards until finding a matching color!`;
                        showMessage(message);
                        updateGameUI();
                    });
                }
            } else {
                // No animation needed, update immediately
                gameState = state;
                isWaitingForServer = false;
                
                // Show message if cards were drawn by opponent
                if (state.lastDrawInfo && state.lastDrawInfo.cardsDrawn && state.lastDrawInfo.playerId !== socket.id) {
                    const count = state.lastDrawInfo.cardsDrawn;
                    const message = count === 1 
                        ? 'Opponent drew a card!'
                        : `Opponent drew ${count} cards!`;
                    showMessage(message);
                }
                
                updateGameUI();
            }
        });

        socket.on('unoCalled', (data) => {
            showMessage(`${data.playerName} called O,NO!`);
        });
        
        socket.on('playerCalledUno', (data) => {
            showMessage(`🔔 ${data.playerName} called O,No!`);
        });
        
        socket.on('unoPenalty', (data) => {
            showMessage(data.message);
        });

        socket.on('unoTransfer', (data) => {
            showMessage(`🔄 ${data.playerName} now has 1 card — they must call O,No!`);
        });

        // 7-swap: server asks this player to pick a target
        socket.on('chooseSwapTarget', ({ opponents }) => {
            showSwapPicker(opponents);
        });

        // Broadcast swap notification to all players
        socket.on('swapHappened', ({ swapperName, targetName, type }) => {
            const isSwapper = swapperName === (gameState && gameState.yourName);
            const isTarget  = targetName  === (gameState && gameState.yourName);
            let msg;
            if (type === '7') {
                if (isSwapper)      msg = `You swapped hands with ${targetName}! 🔄`;
                else if (isTarget)  msg = `${swapperName} swapped hands with you! 🔄`;
                else                msg = `${swapperName} swapped hands with ${targetName}! 🔄`;
            } else {
                if (isSwapper)      msg = `You swapped hands with the next player! 🔄`;
                else if (isTarget)  msg = `${swapperName} swapped hands with you! 🔄`;
                else                msg = `${swapperName} swapped hands! 🔄`;
            }
            showMessage(msg);
        });

        // ==========================================
        // DRAW PENALTY ANIMATION (+2 / +4 / Stack)
        // ==========================================
        socket.on('drawAnimation', (data) => {
            const isVictim = data.victimId === socket.id;
            // Show flash on victim's own screen
            if (isVictim) {
                triggerPenaltyFlash();
            }
            // Animate cards flying from deck to target
            animateDrawPenalty(data, isVictim);
        });

        socket.on('gameOver', (data) => {
            const isWinner = data.winnerId === socket.id;
            setTimeout(() => {
                showPopup(
                    isWinner ? 'You Won!' : 'You Lost!',
                    isWinner ? '🎉 Congratulations!' : '😢 Game Over'
                );
                showMainMenu();
            }, 500);
        });

        socket.on('opponentDisconnected', () => {
            showPopup('Opponent disconnected');
            showMainMenu();
        });

        socket.on('error', (message) => {
            isWaitingForServer = false; // Reset flag on error
            showPopup(message);
        });

        // Player presence events
        socket.on('playerDisconnected', (data) => {
            showDisconnectNotification(
                `${data.playerName} disconnected. Waiting for reconnection...`,
                data.reconnectTimeout
            );
        });

        socket.on('playerTimeout', (data) => {
            showDisconnectNotification(
                `${data.playerName} has been removed from the game.`,
                0,
                'reconnected'
            );
            setTimeout(() => hideDisconnectNotification(), 5000);
        });

        socket.on('gameEnded', (data) => {
            showPopup(data.reason, data.message);
            setTimeout(() => showMainMenu(), 2000);
        });
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', () => {
        // Re-apply theme now that DOM is ready (sets toggle knob emoji correctly)
        const savedTheme = localStorage.getItem('ono-theme') || 'light';
        applyTheme(savedTheme);
        loadBackgroundAnimation();
        initializeSocket();
    });

    // Re-render seats on resize so oval positions stay accurate
    window.addEventListener('resize', () => {
        if (gameState && gameState.allPlayers) renderTableSeats();
    });

    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
    }

    function showMainMenu() {
        const tempRoomId = roomId;
        roomId = null;  // Clear roomId first to prevent race condition
        isReady = false;
        stopHeartbeat();
        hideDisconnectNotification();
        showScreen('mainMenu');
    }

    function showOnlineMenu() {
        showScreen('onlineMenu');
    }

    function showLobbyList() {
        showScreen('lobbyList');
        if (socket && socket.connected) {
            socket.emit('requestLobbies');
        }
    }

    function refreshLobbies() {
        if (socket && socket.connected) {
            socket.emit('requestLobbies');
        }
    }

    function showCreateLobby() {
        showScreen('createLobby');
    }

    function playOffline() {
        window.location.href = '/offline.html';
    }

    function renderLobbyList() {
        const container = document.getElementById('lobbyListContainer');
        container.innerHTML = '';

        if (currentLobbies.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">🎮</div>
                    <p style="font-size: 1.2em; margin-bottom: 10px;">No lobbies available</p>
                    <p style="font-size: 0.9em; color: #95a5a6;">No one is hosting a game right now</p>
                    <p style="font-size: 0.9em; color: #95a5a6; margin-top: 5px;">Go back and create a lobby to get started!</p>
                </div>
            `;
            return;
        }

        currentLobbies.forEach(lobby => {
            const card = document.createElement('div');
            card.className = 'lobby-card' + (lobby.isPrivate ? ' is-private' : '');
            card.onclick = () => joinLobby(lobby.id);

            const rules = [];
            if (lobby.settings.allowStacking) rules.push('<span class="lobby-tag active">+2/+4 Stack</span>');

            if (lobby.settings.allowPlus12) rules.push('<span class="lobby-tag" style="background:rgba(255,140,0,0.2);color:#ff8c00;border:1px solid rgba(255,140,0,0.4);">💀 +12 Card</span>');
            if (lobby.settings.allowJumpIn) rules.push('<span class="lobby-tag active">Jump-In</span>');
            if (rules.length === 0) rules.push('<span class="lobby-tag">Classic Rules</span>');

            const privBadge = lobby.isPrivate
                ? `<span class="lobby-tag" style="background:rgba(231,76,60,0.25);color:#e74c3c;border:1px solid rgba(231,76,60,0.4);">🔒 Private</span>`
                : `<span class="lobby-tag" style="background:rgba(46,204,113,0.2);color:#2ecc71;border:1px solid rgba(46,204,113,0.35);">🌐 Public</span>`;

            card.innerHTML = `
                <div class="lobby-card-header">
                    <div class="lobby-name">${lobby.isPrivate ? '🔒 ' : ''}${lobby.name}</div>
                    <div class="lobby-players">${lobby.players} / ${lobby.settings.maxPlayers || 2}</div>
                </div>
                <div class="lobby-info">
                    <span class="lobby-tag">${lobby.settings.startingCards} Cards</span>
                    ${privBadge}
                    ${rules.join('')}
                </div>
            `;

            container.appendChild(card);
        });
    }

    function togglePasscodeField() {
        const isPrivate = document.getElementById('isPrivate').checked;
        document.getElementById('passcodeField').style.display = isPrivate ? 'block' : 'none';
        if (!isPrivate) document.getElementById('lobbyPasscode').value = '';
    }

    function createLobby() {
        const name = document.getElementById('playerName').value.trim();
        const lobbyName = document.getElementById('lobbyName').value.trim();

        if (!name) {
            showPopup('Please enter your name');
            return;
        }

        if (!lobbyName) {
            showPopup('Please enter a lobby name');
            return;
        }

        const isPrivate = document.getElementById('isPrivate').checked;
        const passcode = document.getElementById('lobbyPasscode').value.trim();

        if (isPrivate && passcode.length < 4) {
            showPopup('Passcode must be at least 4 characters');
            return;
        }

        if (!socket || !socket.connected) {
            showPopup('Not connected to server. Please refresh the page.');
            return;
        }

        const settings = {
            maxPlayers: parseInt(document.getElementById('maxPlayers').value),
            startingCards: parseInt(document.getElementById('startingCards').value),
            allowStacking: document.getElementById('allowStacking').checked,

            allowPlus12: document.getElementById('allowPlus12').checked,
            allowJumpIn: document.getElementById('allowJumpIn').checked,
            drawUntilMatch: document.getElementById('drawUntilMatch').checked
        };

        socket.emit('createLobby', {
            playerName: name,
            lobbyName: lobbyName,
            settings: settings,
            isPrivate: isPrivate,
            passcode: isPrivate ? passcode : null
        });
    }

    function joinLobby(lobbyId) {
        const lobby = currentLobbies.find(l => l.id === lobbyId);
        const name = prompt('Enter your name:');
        if (!name || !name.trim()) return;

        if (!socket || !socket.connected) {
            showPopup('Not connected to server. Please refresh the page.');
            return;
        }

        if (lobby && lobby.isPrivate) {
            const passcode = prompt('🔒 This lobby is private. Enter the passcode:');
            if (passcode === null) return; // cancelled
            socket.emit('joinLobby', { lobbyId, playerName: name.trim(), passcode: passcode.trim() });
        } else {
            socket.emit('joinLobby', { lobbyId, playerName: name.trim() });
        }
    }

    function leaveLobby() {
        const tempRoomId = roomId;
        roomId = null;  // Clear roomId first to prevent race condition
        isReady = false;
        stopHeartbeat();
        if (socket && socket.connected && tempRoomId) {
            socket.emit('leaveLobby', { roomId: tempRoomId });
        }
        showOnlineMenu();
    }

    function showWaitingLobby(lobbyName, settings, players, minPlayers = 2) {
        document.getElementById('waitingLobbyName').textContent = lobbyName;
        
        // Display lobby ID
        if (roomId) {
            document.getElementById('lobbyIdDisplay').textContent = `Lobby ID: ${roomId}`;
        }
        
        const rulesDiv = document.getElementById('waitingRules');
        
        // Categorize rules
        const gameSettings = [];
        const activeRules = [];
        
        gameSettings.push(`<div class="rule-item">🎴 <strong>Starting Cards:</strong> ${settings.startingCards}</div>`);
        gameSettings.push(`<div class="rule-item">👥 <strong>Max Players:</strong> ${settings.maxPlayers}</div>`);
        gameSettings.push(`<div class="rule-item">⚠️ <strong>Min Players:</strong> ${minPlayers}</div>`);
        
        if (settings.allowStacking) {
            activeRules.push(`<div class="rule-item">✅ +2/+4 Stacking Enabled</div>`);
        }

        if (settings.allowPlus12) activeRules.push(`<div class="rule-item">💀 +12 Card Enabled (rare wild)</div>`);
        if (settings.allowJumpIn) {
            activeRules.push(`<div class="rule-item">✅ Jump-In Enabled</div>`);
        }
        if (settings.drawUntilMatch !== false) {
            activeRules.push(`<div class="rule-item">✅ Draw Until Match Enabled</div>`);
        }
        
        const hasActiveRules = settings.allowStacking || 
                               settings.allowJumpIn || settings.allowPlus12 || settings.drawUntilMatch !== false;
        
        let rulesHTML = '<div class="rules-container">';
        
        // Game Settings Section
        rulesHTML += '<div class="rules-section">';
        rulesHTML += '<div class="rules-title">⚙️ Game Settings</div>';
        rulesHTML += gameSettings.join('');
        rulesHTML += '</div>';
        
        // Active Rules or Classic Rules Section
        if (hasActiveRules) {
            rulesHTML += '<div class="rules-section">';
            rulesHTML += '<div class="rules-title">🎮 Active Rules</div>';
            rulesHTML += activeRules.join('');
            rulesHTML += '</div>';
        } else {
            rulesHTML += '<div class="rules-section">';
            rulesHTML += '<div class="rules-title">📋 Classic Rules</div>';
            rulesHTML += '<div class="rule-item">🎯 Playing with standard O,No rules</div>';
            rulesHTML += '</div>';
        }
        
        rulesHTML += '</div>';
        rulesDiv.innerHTML = rulesHTML;

        updateLobbyStatus(players || [{ id: socket.id, name: 'You', ready: false }], minPlayers);
        
        showScreen('waitingLobby');
    }

    function updateLobbyStatus(players, minPlayers = 2) {
        const maxPlayers = currentLobbyData?.settings?.maxPlayers || 2;
        const playerCount = players.length;
        document.getElementById('playerCountText').textContent = `${playerCount} / ${maxPlayers}`;

        const statusDiv = document.getElementById('playersStatus');
        statusDiv.innerHTML = '<div style="display: flex; flex-direction: column; gap: 12px;"></div>';
        const container = statusDiv.firstChild;

        // Show minimum players warning if needed
        if (playerCount < minPlayers) {
            const warning = document.createElement('div');
            warning.className = 'min-players-warning';
            warning.innerHTML = `⚠️ Need at least ${minPlayers} players to start the game!<br><span style="font-size: 0.9em;">(Currently ${playerCount} / ${minPlayers})</span>`;
            container.appendChild(warning);
        }

        // Player avatars/emojis for variety
        const avatars = ['👤', '🎮', '🎯', '🎲', '🃏', '🎪', '🎭', '🎨'];

        // Show all current players
        players.forEach((player, index) => {
            const isYou = player.id === socket.id;
            const isHost = index === 0; // First player is host
            
            const playerDiv = document.createElement('div');
            playerDiv.className = `player-slot${isYou ? ' you' : ''}`;
            
            // Player Avatar
            const avatar = document.createElement('div');
            avatar.className = 'player-avatar';
            avatar.textContent = avatars[index % avatars.length];
            
            // Player Info
            const info = document.createElement('div');
            info.className = 'player-info';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'player-name';
            
            const nameText = document.createElement('span');
            nameText.textContent = isYou ? '👋 You' : player.name;
            nameDiv.appendChild(nameText);
            
            // Host badge
            if (isHost) {
                const hostBadge = document.createElement('span');
                hostBadge.className = 'host-badge';
                hostBadge.textContent = '👑 Host';
                nameDiv.appendChild(hostBadge);
            }
            
            info.appendChild(nameDiv);
            
            // Ready Badge
            const readyBadge = document.createElement('div');
            readyBadge.className = `ready-badge ${player.ready ? 'ready' : 'not-ready'}`;
            if (player.ready) {
                readyBadge.textContent = '✓ Ready';
            } else {
                readyBadge.textContent = '⏳ Not Ready';
            }
            
            playerDiv.appendChild(avatar);
            playerDiv.appendChild(info);
            playerDiv.appendChild(readyBadge);
            container.appendChild(playerDiv);
        });

        // Show empty slots
        for (let i = playerCount; i < maxPlayers; i++) {
            const emptyDiv = document.createElement('div');
            emptyDiv.className = 'player-slot empty';
            
            const avatar = document.createElement('div');
            avatar.className = 'player-avatar empty';
            avatar.textContent = '👤';
            
            const info = document.createElement('div');
            info.className = 'player-info';
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'player-name';
            nameDiv.style.color = '#95a5a6';
            nameDiv.textContent = 'Waiting for player...';
            
            info.appendChild(nameDiv);
            
            const readyBadge = document.createElement('div');
            readyBadge.className = 'ready-badge empty';
            readyBadge.textContent = '-';
            
            emptyDiv.appendChild(avatar);
            emptyDiv.appendChild(info);
            emptyDiv.appendChild(readyBadge);
            container.appendChild(emptyDiv);
        }

        // Update ready status bar
        const readyCount = players.filter(p => p.ready).length;
        const readyStatusBar = document.getElementById('readyStatusBar');
        
        if (playerCount >= minPlayers) {
            readyStatusBar.style.display = 'block';
            
            if (readyCount === playerCount) {
                readyStatusBar.className = 'ready-status-bar all-ready';
                readyStatusBar.innerHTML = '🎉 All players ready! Starting game...';
            } else {
                readyStatusBar.className = 'ready-status-bar waiting';
                readyStatusBar.innerHTML = `⏳ Waiting for players to ready up... (${readyCount}/${playerCount} ready)`;
            }
        } else {
            readyStatusBar.style.display = 'none';
        }

        // Show/hide waiting message
        const waitingMessage = document.getElementById('waitingMessage');
        if (playerCount < minPlayers) {
            waitingMessage.style.display = 'flex';
            const messageSpan = waitingMessage.querySelector('span:last-child');
            if (messageSpan) {
                messageSpan.textContent = `Waiting for more players to join... (${playerCount}/${minPlayers})`;
            }
        } else {
            waitingMessage.style.display = 'none';
        }

        // Show ready button if lobby has at least minimum players
        const readyButton = document.getElementById('readyButton');
        if (playerCount >= minPlayers) {
            readyButton.style.display = 'block';
            // Update button state based on current ready status
            const currentPlayer = players.find(p => p.id === socket.id);
            if (currentPlayer && currentPlayer.ready) {
                readyButton.classList.add('is-ready');
            } else {
                readyButton.classList.remove('is-ready');
            }
        } else {
            readyButton.style.display = 'none';
        }
    }

    function toggleReady() {
        if (!socket || !socket.connected || !roomId) return;
        
        isReady = !isReady;
        const btn = document.getElementById('readyButton');
        
        if (isReady) {
            btn.textContent = '✓ Ready!';
            btn.classList.add('is-ready');
            btn.style.background = 'linear-gradient(135deg, #2ecc71 0%, #27ae60 100%)';
        } else {
            btn.textContent = '⏳ Ready Up!';
            btn.classList.remove('is-ready');
            btn.style.background = 'linear-gradient(135deg, #f39c12 0%, #e67e22 100%)';
        }
        
        socket.emit('playerReady', { roomId: roomId, ready: isReady });
    }

    // Heartbeat management
    function startHeartbeat() {
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
        }
        
        console.log('[Client] Starting heartbeat');
        heartbeatInterval = setInterval(() => {
            if (socket && socket.connected && roomId) {
                socket.emit('heartbeat', { roomId: roomId });
            }
        }, 5000); // Send heartbeat every 5 seconds
    }

    function stopHeartbeat() {
        if (heartbeatInterval) {
            console.log('[Client] Stopping heartbeat');
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }
    }

    // Disconnect notification management
    function showDisconnectNotification(message, timeout = 0, type = 'disconnected') {
        const notification = document.getElementById('disconnectNotification');
        
        if (type === 'reconnected') {
            notification.className = 'disconnect-notification active reconnected';
        } else {
            notification.className = 'disconnect-notification active';
        }
        
        if (timeout > 0) {
            const seconds = Math.ceil(timeout / 1000);
            notification.innerHTML = `
                ${message}
                <span class="reconnect-timer">Grace period: ${seconds} seconds</span>
            `;
            
            // Update timer countdown
            let remaining = seconds;
            if (disconnectNotificationTimeout) {
                clearInterval(disconnectNotificationTimeout);
            }
            
            disconnectNotificationTimeout = setInterval(() => {
                remaining--;
                if (remaining <= 0) {
                    clearInterval(disconnectNotificationTimeout);
                    hideDisconnectNotification();
                } else {
                    const timerSpan = notification.querySelector('.reconnect-timer');
                    if (timerSpan) {
                        timerSpan.textContent = `Grace period: ${remaining} seconds`;
                    }
                }
            }, 1000);
        } else {
            notification.textContent = message;
        }
    }

    function hideDisconnectNotification() {
        const notification = document.getElementById('disconnectNotification');
        notification.classList.remove('active');
        
        if (disconnectNotificationTimeout) {
            clearInterval(disconnectNotificationTimeout);
            disconnectNotificationTimeout = null;
        }
    }

    function leaveGame() {
        showConfirm('Are you sure you want to leave?', (confirmed) => {
            if (confirmed) {
                prevStackCount = 0;
                jumpInBannerVisible = false;
                updateJumpInBanner(false);
                if (socket) {
                    socket.disconnect();
                    socket.connect();
                }
                showMainMenu();
            }
        });
    }

    // Game functions (keep existing game logic)
    function updateGameUI() {
        if (!gameState) return;

        try {
            document.getElementById('currentColor').textContent = gameState.currentColor || '-';
            document.getElementById('deckCount').textContent = gameState.deckCount;

            // Render oval player seats
            renderTableSeats();

            renderDiscardPile();
            renderPlayerHand();

            // Update stack indicator with animation when count increases
            const stackIndicator = document.getElementById('stackIndicator');
            const newStackCount = gameState.stackedDrawCount || 0;
            const stackIncreased = newStackCount > prevStackCount && prevStackCount > 0;
            const stackJustStarted = newStackCount > 0 && prevStackCount === 0;
            const increment = newStackCount - prevStackCount;

            if (newStackCount > 0) {
                const cardType = gameState.currentValue === '+2' ? '+2' : '+4';

                stackIndicator.innerHTML = `
                    <div style="font-size: 0.78em; opacity: 0.85; margin-bottom: 1px;">${cardType} Stack</div>
                    <span class="stack-count-num" id="stackCountNum">Draw ${newStackCount}</span>
                `;
                stackIndicator.classList.add('active');

                if (stackJustStarted) {
                    stackIndicator.classList.remove('stack-bump');
                    void stackIndicator.offsetWidth;
                    stackIndicator.classList.add('stack-bump');
                } else if (stackIncreased) {
                    stackIndicator.classList.remove('stack-bump');
                    void stackIndicator.offsetWidth;
                    stackIndicator.classList.add('stack-bump');

                    const numEl = document.getElementById('stackCountNum');
                    if (numEl) {
                        numEl.classList.remove('num-change');
                        void numEl.offsetWidth;
                        numEl.classList.add('num-change');
                    }

                    const badge = document.createElement('div');
                    badge.className = 'stack-increment-badge';
                    badge.textContent = `+${increment}`;
                    stackIndicator.appendChild(badge);
                    setTimeout(() => badge.remove(), 950);
                }
            } else {
                stackIndicator.innerHTML = '';
                stackIndicator.classList.remove('active', 'stack-bump');
            }
            prevStackCount = newStackCount;

            // Direction arrows
            updateDirectionArrows();

            if (gameState.isYourTurn) {
                showMessage('Your turn!');
                const drawPileEl = document.getElementById('drawPile');
                if (gameState.hasDrawnThisTurn) {
                    drawPileEl.style.opacity = '0.35';
                    drawPileEl.style.cursor = 'not-allowed';
                    drawPileEl.style.pointerEvents = 'none';
                } else {
                    drawPileEl.style.opacity = '';
                    drawPileEl.style.cursor = 'pointer';
                    drawPileEl.style.pointerEvents = '';
                }
            } else {
                showMessage(`${gameState.currentPlayerName}'s turn...`);
                const drawPileEl = document.getElementById('drawPile');
                drawPileEl.style.opacity = '';
                drawPileEl.style.cursor = 'not-allowed';
                drawPileEl.style.pointerEvents = 'none';
            }

            // O,No button: only show when you have exactly 1 card and haven't called it yet
            const unoBtn = document.getElementById('unoButton');
            const myPlayer = gameState.allPlayers && gameState.allPlayers.find(p => p.isYou);
            const shouldShowUno = gameState.yourHand &&
                                  gameState.yourHand.length === 1 &&
                                  myPlayer && !myPlayer.calledUno;
            if (shouldShowUno) {
                unoBtn.classList.add('active');
            } else {
                unoBtn.classList.remove('active');
            }
            // Auto-draw stacked cards if it's your turn, there's a stack,
            // and you have no card that can stack on it
            if (gameState.isYourTurn && gameState.stackedDrawCount > 0 && !isWaitingForServer) {
                const hasStackCard = gameState.yourHand && gameState.yourHand.some(card => {
                    if (gameState.currentValue === '+2'     && card.value === '+2')     return true;
                    if (gameState.currentValue === 'Wild+4' && card.value === 'Wild+4') return true;
                    return false;
                });
                if (!hasStackCard) {
                    // No stackable card — automatically absorb the penalty
                    isWaitingForServer = true;
                    setTimeout(() => {
                        if (socket && socket.connected) {
                            socket.emit('drawCard', { roomId });
                        }
                    }, 600); // short delay so player sees the stack count before it resolves
                }
            }

        } catch (error) {
            console.error('Error updating UI:', error);
        }
    }

    // =============================================
    //  OVAL TABLE SEAT RENDERER
    // =============================================
    function renderTableSeats() {
        const arena = document.getElementById('tableArena');
        const seatsDiv = document.getElementById('tableSeats');
        if (!seatsDiv || !gameState.allPlayers) return;
        seatsDiv.innerHTML = '';

        const players = gameState.allPlayers;
        const n = players.length;
        const arenaW = arena.offsetWidth  || 820;
        const arenaH = arena.offsetHeight || 615;

        // Oval radii — seats sit just inside the border ring
        const rx = arenaW * 0.43;
        const ry = arenaH * 0.40;

        // "You" always sit at the bottom (angle = 90° = π/2 from positive X = bottom)
        // We find our index and offset so our seat lands at bottom
        const yourIdx = players.findIndex(p => p.isYou);
        // angle for seat i: start from bottom (π/2), go clockwise for direction=1
        // evenly spaced around the oval
        const angleOffset = Math.PI / 2; // bottom center

        players.forEach((player, i) => {
            // Offset so "you" is always at bottom
            const relIdx = (i - yourIdx + n) % n;
            // Evenly space: clockwise from bottom
            const angle = angleOffset + (relIdx / n) * 2 * Math.PI;

            const cx = arenaW / 2 + rx * Math.cos(angle);
            const cy = arenaH / 2 + ry * Math.sin(angle);

            const seat = document.createElement('div');
            seat.className = 'player-seat';
            seat.style.left = cx + 'px';
            seat.style.top  = cy + 'px';
            seat.dataset.playerId = player.id;

            const boxClasses = ['seat-box',
                player.isYou     ? 'is-you'     : '',
                player.isCurrent ? 'is-current'  : ''
            ].filter(Boolean).join(' ');

            // O,No ribbon — show on anyone (including you) who has called O,No
            const onoRibbon = player.calledUno
                ? `<div class="ono-ribbon">O,NO!</div>` : '';

            // Catch button — only show on opponents with 1 card who haven't called O,No
            const catchBtn = (!player.isYou && player.cardCount === 1 && !player.calledUno)
                ? `<button class="catch-button" data-id="${player.id}">Catch!</button>` : '';

            const turnLabel = player.isCurrent
                ? `<div class="seat-turn-badge">${player.isYou ? '⭐ Your Turn' : '⏰ Their Turn'}</div>` : '';

            const youBadge = player.isYou
                ? `<div class="seat-you-badge">YOU</div>` : '';

            seat.innerHTML = `
                <div class="${boxClasses}">
                    ${onoRibbon}
                    <div class="seat-name">${player.name}</div>
                    <div class="seat-cards">${player.cardCount} 🎴</div>
                    ${turnLabel}
                    ${youBadge}
                    ${catchBtn}
                </div>
            `;

            if (!player.isYou && player.cardCount === 1) {
                const btn = seat.querySelector('.catch-button');
                if (btn) btn.addEventListener('click', () => catchOpponent(player.id));
            }

            seatsDiv.appendChild(seat);
        });
    }

    function updateDirectionArrows() {
        const dir = gameState.direction ?? 1;
        const arcCW  = document.getElementById('arcCW');
        const arcCCW = document.getElementById('arcCCW');
        if (!arcCW || !arcCCW) return;
        if (dir === 1) {
            arcCW.style.display  = '';
            arcCCW.style.display = 'none';
        } else {
            arcCW.style.display  = 'none';
            arcCCW.style.display = '';
        }
    }

    function renderDiscardPile() {
        const discardDiv = document.getElementById('discardPile');
        discardDiv.innerHTML = '';
        
        if (gameState.discardPile) {
            const card = gameState.discardPile;
            const cardDiv = createCardElement(card);
            
            if (card.type === 'wild' && gameState.currentColor) {
                cardDiv.style.borderColor = getColorHex(gameState.currentColor);
                cardDiv.style.borderWidth = '6px';
                
                const indicator = document.createElement('div');
                indicator.className = 'wild-color-indicator';
                indicator.style.backgroundColor = getColorHex(gameState.currentColor);
                cardDiv.appendChild(indicator);
            }
            
            discardDiv.appendChild(cardDiv);
        }
    }

    function renderPlayerHand() {
        const handDiv = document.getElementById('playerHand');
        handDiv.innerHTML = '';
        
        if (!gameState.yourHand) return;
        
        if (gameState.isYourTurn) {
            handDiv.classList.add('your-turn');
        } else {
            handDiv.classList.remove('your-turn');
        }

        let hasJumpInCard = false;
        let jumpInLabel = '⚡ JUMP IN!';
        
        gameState.yourHand.forEach((card, index) => {
            const isPlayable = canPlayCard(card);
            const isJumpIn   = canJumpIn(card);
            const cardDiv    = createCardElement(card);
            
            if (isJumpIn) {
                hasJumpInCard = true;
                // Pick the most specific label
                if (card.value === 'Wild+4') jumpInLabel = '⚡ JUMP IN! Wild +4';
                else if (card.value === '+2')  jumpInLabel = '⚡ JUMP IN! +2';
                cardDiv.classList.add('jump-in-card');
                cardDiv.onclick = () => playCard(index, true);
            } else if (!isPlayable || !gameState.isYourTurn || isWaitingForServer) {
                cardDiv.classList.add('disabled');
            } else {
                cardDiv.onclick = () => playCard(index, false);
            }
            
            handDiv.appendChild(cardDiv);
        });

        // Show or hide the jump-in banner
        updateJumpInBanner(hasJumpInCard, jumpInLabel);
    }

    let jumpInBannerVisible = false;
    function updateJumpInBanner(show, label = '⚡ JUMP IN!') {
        const banner = document.getElementById('jumpInBanner');
        if (!banner) return;
        if (show && !jumpInBannerVisible) {
            jumpInBannerVisible = true;
            banner.textContent = label;
            banner.classList.remove('hiding');
            banner.classList.add('visible');
        } else if (show && jumpInBannerVisible) {
            // Update label if already showing
            banner.textContent = label;
        } else if (!show && jumpInBannerVisible) {
            jumpInBannerVisible = false;
            banner.classList.remove('visible');
            banner.classList.add('hiding');
            setTimeout(() => {
                banner.classList.remove('hiding');
            }, 280);
        }
    }

    function createCardElement(card) {
        const cardDiv = document.createElement('div');
        // +12 gets its own CSS class instead of 'wild'
        const colorClass = card.value === '+12' ? 'plus12' : card.color;
        cardDiv.className = `card ${colorClass}`;
        
        const cardInner = document.createElement('div');
        cardInner.className = 'card-inner';
        cardInner.textContent = card.value;
        cardDiv.appendChild(cardInner);
        
        return cardDiv;
    }

    // Animation helper function: Animate a card from source element to target element
    function animateCardToCenter(cardElement, card, onComplete) {
        if (!cardElement) {
            onComplete();
            return;
        }
        
        // Get positions
        const startRect = cardElement.getBoundingClientRect();
        const discardPileElement = document.getElementById('discardPile');
        const endRect = discardPileElement.getBoundingClientRect();
        
        // Clone the card for animation
        const clone = cardElement.cloneNode(true);
        clone.className = `card ${card.color} card-fly-to-center`;
        clone.style.left = startRect.left + 'px';
        clone.style.top = startRect.top + 'px';
        clone.style.width = startRect.width + 'px';
        clone.style.height = startRect.height + 'px';
        clone.style.transform = 'scale(1) rotate(5deg)';
        clone.style.opacity = '0.9';
        
        document.body.appendChild(clone);
        
        // Calculate arc motion - card goes up first, then down
        const midY = Math.min(startRect.top, endRect.top) - 50;
        
        // Trigger animation with arc motion
        requestAnimationFrame(() => {
            // First animate to arc peak
            setTimeout(() => {
                clone.style.left = (startRect.left + endRect.left) / 2 + 'px';
                clone.style.top = midY + 'px';
                clone.style.transform = 'scale(1.05) rotate(-3deg)';
            }, 50);
            
            // Then animate to final position
            setTimeout(() => {
                clone.style.left = endRect.left + 'px';
                clone.style.top = endRect.top + 'px';
                clone.style.transform = 'scale(1.1) rotate(0deg)';
                clone.style.opacity = '1';
            }, 300);
        });
        
        // Add landing animation to discard pile
        setTimeout(() => {
            discardPileElement.classList.add('discard-pile-pulse');
            setTimeout(() => {
                discardPileElement.classList.remove('discard-pile-pulse');
            }, 300);
        }, 600);
        
        // Clean up after animation
        setTimeout(() => {
            clone.remove();
            onComplete();
        }, 600);
    }

    // Animation helper function: Animate a card-back from draw pile to hand
    // Note: targetArea parameter is kept for API consistency with offline.html but not used
    // in online mode since we only animate to the local player's hand
    function animateCardToHand(targetArea, onComplete) {
        const drawPile = document.getElementById('drawPile');
        const startRect = drawPile.getBoundingClientRect();
        const playerHand = document.getElementById('playerHand');
        const endRect = playerHand.getBoundingClientRect();
        
        // Create card-back element
        const cardBack = document.createElement('div');
        cardBack.className = 'card card-back card-fly-to-hand';
        cardBack.innerHTML = '<div class="card-inner" style="font-size:0.65em; color:rgba(255,255,255,0.65); background:rgba(255,255,255,0.08); font-family:Orbitron,sans-serif; letter-spacing:1px;">DRAW</div>';
        cardBack.style.left = startRect.left + 'px';
        cardBack.style.top = startRect.top + 'px';
        cardBack.style.width = startRect.width + 'px';
        cardBack.style.height = startRect.height + 'px';
        cardBack.style.transform = 'scale(0.8) rotateY(0deg) rotate(-5deg)';
        cardBack.style.opacity = '0.5';
        
        document.body.appendChild(cardBack);
        
        // Calculate arc motion
        const midY = Math.min(startRect.top, endRect.top) - 40;
        
        // Trigger animation with arc and flip
        requestAnimationFrame(() => {
            // Animate to arc peak with rotation
            setTimeout(() => {
                cardBack.style.left = (startRect.left + endRect.left) / 2 + 'px';
                cardBack.style.top = midY + 'px';
                cardBack.style.transform = 'scale(0.9) rotateY(90deg) rotate(0deg)';
                cardBack.style.opacity = '0.7';
            }, 50);
            
            // Animate to final position with flip completion
            setTimeout(() => {
                cardBack.style.left = endRect.left + 'px';
                cardBack.style.top = endRect.top + 'px';
                cardBack.style.transform = 'scale(1) rotateY(180deg) rotate(5deg)';
                cardBack.style.opacity = '1';
            }, 300);
            
            // Final settle
            setTimeout(() => {
                cardBack.style.transform = 'scale(1) rotateY(180deg) rotate(0deg)';
            }, 500);
        });
        
        // Clean up after animation
        setTimeout(() => {
            cardBack.remove();
            onComplete();
        }, 600);
    }

    // Animation helper function: Animate multiple cards with stagger
    function animateMultipleCardsToHand(count, onComplete) {
        let completed = 0;
        
        function animateNext(index) {
            if (index >= count) {
                return;
            }
            
            animateCardToHand('player', () => {
                completed++;
                if (completed === count) {
                    onComplete();
                }
            });
            
            // Stagger animation by 200ms per card
            if (index + 1 < count) {
                setTimeout(() => animateNext(index + 1), 200);
            }
        }
        
        animateNext(0);
    }

    // ============================================================
    //  DRAW PENALTY ANIMATION SYSTEM
    //  Flies cards from deck → victim (opponent box or player hand)
    // ============================================================

    function triggerPenaltyFlash() {
        const flash = document.getElementById('penaltyFlash');
        if (!flash) return;
        flash.classList.remove('flashing');
        // Force reflow to restart animation
        void flash.offsetWidth;
        flash.classList.add('flashing');
        setTimeout(() => flash.classList.remove('flashing'), 800);
    }

    function spawnSparkle(x, y, color) {
        const s = document.createElement('div');
        s.className = 'card-sparkle';
        s.style.left = x + 'px';
        s.style.top  = y + 'px';
        s.style.background = color;
        s.style.boxShadow  = `0 0 6px ${color}`;
        document.body.appendChild(s);
        setTimeout(() => s.remove(), 450);
    }

    function animateDrawPenalty(data, isVictim) {
        const { count, cardValue, victimId, victimName, stacking } = data;
        const drawPile = document.getElementById('drawPile');
        if (!drawPile) return;

        const srcRect = drawPile.getBoundingClientRect();

        // Find target element: player's own hand or opponent's seat box
        let targetEl = null;
        if (isVictim) {
            targetEl = document.getElementById('playerHand');
        } else {
            // Find the opponent seat by player id or name
            if (data.victimId) {
                const seat = document.querySelector(`.player-seat[data-player-id="${data.victimId}"]`);
                if (seat) targetEl = seat;
            }
            if (!targetEl && victimName) {
                const seats = document.querySelectorAll('.player-seat');
                for (const seat of seats) {
                    if (seat.textContent.includes(victimName)) {
                        targetEl = seat;
                        break;
                    }
                }
            }
            if (!targetEl) targetEl = document.getElementById('tableSeats');
        }

        const endRect = targetEl ? targetEl.getBoundingClientRect() : srcRect;
        const endX = endRect.left + endRect.width / 2;
        const endY = endRect.top  + endRect.height / 2;

        // Penalty badge colors
        const isBig  = cardValue === 'Wild+4' || cardValue === '+12' || count >= 4;
        const accent = cardValue === '+12' ? '#ff8c00' : isBig ? '#ff4b2b' : '#ff416c';
        const label  = cardValue === 'stack'
            ? `Draw ${count}!`
            : cardValue === '+12'
                ? '💀 +12 Draw!'
                : stacking
                    ? cardValue === 'Wild+4' ? '+4 Stacked!' : '+2 Stacked!'
                    : cardValue === 'Wild+4' ? '+4 Draw!' : '+2 Draw!';

        // Stagger cards
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                const card = document.createElement('div');
                card.className = 'draw-penalty-card';
                card.innerHTML = '🎴';
                card.style.left   = srcRect.left + 'px';
                card.style.top    = srcRect.top  + 'px';
                card.style.width  = srcRect.width  + 'px';
                card.style.height = srcRect.height + 'px';
                card.style.transform = 'scale(0.85) rotate(-8deg)';
                card.style.opacity = '1';
                card.style.boxShadow = `0 4px 20px rgba(0,0,0,0.5), 0 0 20px ${accent}88`;

                document.body.appendChild(card);

                // Arc midpoint (raise cards upward for drama)
                const midX = (srcRect.left + endX) / 2;
                const midY = Math.min(srcRect.top, endY) - 80 - i * 10;

                requestAnimationFrame(() => {
                    // Phase 1: Arc to midpoint
                    setTimeout(() => {
                        card.style.transition = `left 0.28s ease-out, top 0.28s ease-out, transform 0.28s ease-out, opacity 0.28s ease`;
                        card.style.left = midX + 'px';
                        card.style.top  = midY + 'px';
                        card.style.transform = `scale(1.1) rotate(${i % 2 === 0 ? '5deg' : '-5deg'})`;

                        // Sparkle trail at midpoint
                        setTimeout(() => {
                            for (let s = 0; s < 4; s++) {
                                setTimeout(() => spawnSparkle(
                                    midX + (Math.random() - 0.5) * 40,
                                    midY + (Math.random() - 0.5) * 40,
                                    accent
                                ), s * 50);
                            }
                        }, 140);
                    }, 30);

                    // Phase 2: Land at target
                    setTimeout(() => {
                        card.style.transition = `left 0.28s cubic-bezier(0.34,1.2,0.64,1), top 0.28s cubic-bezier(0.34,1.2,0.64,1), transform 0.28s cubic-bezier(0.34,1.2,0.64,1), opacity 0.2s ease`;
                        card.style.left = (endX - srcRect.width / 2)  + 'px';
                        card.style.top  = (endY - srcRect.height / 2) + 'px';
                        card.style.transform = `scale(0.9) rotate(${(i - count/2) * 5}deg)`;

                        // Shake target element on last card
                        if (i === count - 1 && targetEl) {
                            setTimeout(() => {
                                targetEl.classList.add('victim-shaking');
                                setTimeout(() => targetEl.classList.remove('victim-shaking'), 600);

                                // Show penalty burst badge
                                showPenaltyBurst(endX, endY, label, victimName, isVictim, accent);
                            }, 100);
                        }
                    }, 310);

                    // Remove flying card
                    setTimeout(() => {
                        card.style.opacity = '0';
                        setTimeout(() => card.remove(), 200);
                    }, 550);
                });
            }, i * 140);
        }
    }

    function showPenaltyBurst(x, y, label, name, isVictim, color) {
        const burst = document.createElement('div');
        burst.className = 'penalty-burst';
        burst.style.left = (x - 80) + 'px';
        burst.style.top  = (y - 55) + 'px';

        const who = isVictim ? 'You draw!' : `${name} draws!`;
        burst.innerHTML = `
            <div class="penalty-burst-badge" style="background: linear-gradient(135deg, ${color}, ${color}cc);">
                ${label}
            </div>
            <div class="penalty-burst-sub">${who}</div>
        `;
        document.body.appendChild(burst);
        setTimeout(() => burst.remove(), 1300);
    }

    function canJumpIn(card) {
        if (!gameState || !gameState.settings.allowJumpIn) return false;
        if (gameState.isYourTurn) return false;
        if (!card) return false;
        if (gameState.stackedDrawCount > 0) return false; // can't jump in during a draw stack

        if (card.value === 'Wild+4') {
            // Wild+4 can always jump in
            return true;
        }
        if (card.value === '+2') {
            // +2 jump in only when same color as current
            return card.color === gameState.currentColor;
        }
        if (card.type === 'number') {
            // Number card: exact match (same color AND same value)
            return card.color === gameState.currentColor && card.value === gameState.currentValue;
        }
        return false;
    }

    function canPlayCard(card) {
        if (!gameState || !card) return false;
        if (card.type === 'wild') return true;
        
        if (gameState.settings.allowStacking && gameState.stackedDrawCount > 0) {
            if (gameState.currentValue === '+2' && card.value === '+2') return true;
            if (gameState.currentValue === 'Wild+4' && card.value === 'Wild+4') return true;
            return false;
        }
        
        return card.color === gameState.currentColor || card.value === gameState.currentValue;
    }

    function playCard(index, isJumpIn = false) {
        if (!gameState || !gameState.yourHand) return;
        if (!gameState.isYourTurn && !isJumpIn) return;
        if (isWaitingForServer) return;
        
        const card = gameState.yourHand[index];
        if (!card) return;
        
        // Validate: normal turn needs canPlayCard, jump-in needs canJumpIn
        if (isJumpIn) {
            if (!canJumpIn(card)) return;
        } else {
            if (!canPlayCard(card)) return;
        }
        
        // Hide jump-in banner immediately on play
        updateJumpInBanner(false);

        const yourHandDiv = document.getElementById('playerHand');
        const cardElement = yourHandDiv.children[index];
        
        if (card.type === 'wild') {
            pendingCardIndex = index;
            showColorPicker();
        } else {
            isWaitingForServer = true;
            animateCardToCenter(cardElement, card, () => {
                if (socket && socket.connected) {
                    socket.emit('playCard', {
                        roomId: roomId,
                        cardIndex: index,
                        chosenColor: null
                    });
                }
            });
        }
    }

    function showColorPicker() {
        document.getElementById('overlay').classList.add('active');
        document.getElementById('colorPicker').classList.add('active');
    }

    function chooseColor(color) {
        document.getElementById('overlay').classList.remove('active');
        document.getElementById('colorPicker').classList.remove('active');
        
        // Get the card element and animate it
        const card = gameState.yourHand[pendingCardIndex];
        const yourHandDiv = document.getElementById('playerHand');
        const cardElement = yourHandDiv.children[pendingCardIndex];
        
        // Block further plays before starting animation
        isWaitingForServer = true;
        
        animateCardToCenter(cardElement, card, () => {
            if (socket && socket.connected) {
                socket.emit('playCard', {
                    roomId: roomId,
                    cardIndex: pendingCardIndex,
                    chosenColor: color
                });
            }
            
            pendingCardIndex = null;
        });
    }

    // ── 7-Swap picker ─────────────────────────────────────────────
    function showSwapPicker(opponents) {
        const optionsDiv = document.getElementById('swapOptions');
        optionsDiv.innerHTML = '';
        opponents.forEach(opp => {
            const btn = document.createElement('button');
            btn.className = 'swap-option-btn';
            btn.textContent = opp.name;
            btn.onclick = () => confirmSwapTarget(opp.id);
            optionsDiv.appendChild(btn);
        });
        document.getElementById('overlay').classList.add('active');
        document.getElementById('swapPicker').classList.add('active');
    }

    function confirmSwapTarget(targetId) {
        document.getElementById('overlay').classList.remove('active');
        document.getElementById('swapPicker').classList.remove('active');
        if (socket && socket.connected) {
            socket.emit('chooseSwapTarget', { roomId, targetId });
        }
    }

    function drawCard() {
        if (!gameState || !gameState.isYourTurn) return;
        if (gameState.hasDrawnThisTurn) return; // already drew this turn
        if (isWaitingForServer) return; // Prevent rapid clicking
        
        // Block further actions while waiting for server
        isWaitingForServer = true;
        
        // Send draw request to server (no animation yet - wait for response)
        if (socket && socket.connected) {
            socket.emit('drawCard', { roomId: roomId });
        }
    }

    function callUno() {
        if (socket && socket.connected) {
            socket.emit('callUno', { roomId: roomId });
            showMessage('O,NO!');
        }
    }
    
    function catchOpponent(opponentId) {
        if (socket && socket.connected) {
            socket.emit('catchUno', { roomId: roomId, caughtPlayerId: opponentId });
        }
    }

    function showMessage(msg) {
        document.getElementById('message').textContent = msg;
    }

    function getColorHex(color) {
        const map = {
            'red': '#e74c3c',
            'blue': '#3498db',
            'green': '#2ecc71',
            'yellow': '#f1c40f'
        };
        return map[color] || '#ffffff';
    }
</script>

</body>
</html>
